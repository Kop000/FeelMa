<!DOCTYPE html>


<html lang="zh-hans">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 一只鼻孔在路上</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/images/3.jpg" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <script src="https://cdn.staticfile.org/mermaid/8.14.0/mermaid.min.js"></script>
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/2.jpg" alt="image frame" />
    </div>
    <!-- <div class="cover-inner text-center text-white">
      <h1><a href="/">一只鼻孔在路上</a></h1>
      <div id="subtitle-box">
        
          <span id="subtitle"></span>
        
      </div>
      <div>
        
        <img
          src="true"
          class="cover-logo"
          alt="一只鼻孔在路上"
        />
        
      </div>
    </div> -->
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>




<!-- Subtitle -->

<div id="main">
  <section class="outer">
  
  
  <article class="articles">
    
    
    
    
    <article
  id="post-宏观经济小分析"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/10/29/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%B0%8F%E5%88%86%E6%9E%90/"
    >宏观经济小分析</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/10/29/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%B0%8F%E5%88%86%E6%9E%90/" class="article-date">
  <time datetime="2023-10-29T10:39:06.000Z" itemprop="datePublished">2023-10-29</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%90%8E%E5%A4%87%E7%AE%B1/">后备箱</a>
  </div>
 
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>在参与今年秋招之前，我并没有亲身感受过当前国内经济形势，生活上也只是从妈妈抱怨生意越来越难做、街头的餐馆开了又倒闭、新闻报道裁员增多等别人的感受里强行感受。三年前决定读计算机作为专业的主要原因，就是听亲戚、网上说计算机出来好就业、吃得香，学校还被称为”信息黄埔“，于是当我满怀信心投身这场没有硝烟的战争里，最终却被打得头破血流，重新又躲回了校园。听说几年前大厂都是随便进，IOS研发岗面试问你用过苹果吗，用过就进，当然这有点夸张，但也说明当前互联网行业的人才过饱和，原因有二，经济下行，以及竞争人数过多。我应聘的岗位还是Java后端，更是亲身感受到卷无上限，技术栈无限叠加，被逼着学，这是底层程序员的悲哀，也是随着大流走的惩罚，向我一样的人很多，比我形式难的人更多。</p>
<p>这个世界划开了一道口子，我看到了真实的世界。</p>
<p>静下来的这段时间，我不由得想一个问题，<strong>目前的国内经济形势究竟如何？</strong></p>
<p>有没有方法和真实的数据让我看清楚当前经济？最近国家发行的一万亿国债究竟是为什么？前阵子讨论很火的房地产新政策又是什么？</p>
<p>作为一个0基础的经济学小白，我第一步是上网搜了这个问题，给出的解释涉及很多名词看不懂，同时这又是经济，或多或少是敏感的，只有数据不会骗人。</p>
<p>那么问题变成：通过哪些数据能分析出当前经济情况呢？</p>
<h4 id="生产总值GDP"><a href="#生产总值GDP" class="headerlink" title="生产总值GDP"></a>生产总值GDP</h4><p>最直接的，可以通过国内生产总值来衡量当前国内的经济发展总体情况。</p>
<p>GDP gross domestic product，一国（地区）再一定时期内生产的所有最终产品的市场价值。其统计方法简单来说，就是对我国常住单位进行核算产值，方法有生产法、支出法和收入法，根据《国民经济行业分类标准》对行业划分统计。</p>
<p>如果说物理上我的两只眼睛可以看到真实落在地上的世界，在我大一下的某天下午，我窝在安静的沙河教学楼里第一次看到计算机网络勾勒出的，倒挂在真实世界之上的虚拟世界就是人类存在的第二世界，那么这一次，我站在GDP这个滤镜下看到了第三世界，这个世界里每个国家、企业、个体都是力气。努力这个以前我总觉得抽象到无法直接解释的词语，这一次有了答案。你每天工作上班，换来的并不只有工资和福利，还有一个个产品和成果，<strong>这些成果并非凭空消失</strong>，统计局会帮你统计下来，是可以量化的。</p>
<p>每年每季度，统计局就会对这段时间国家所有人的努力做个汇总，即生产总值，这个公司这三个月生产了500台风扇，那个厂今年有3000枚鸡蛋，这些成果，都是全国几十亿人在吃了多少公斤大米共同生产出来创造出来的成品，这么想每个人都对历史做出了改变，虽然可能只是0.0000000..1%（哈哈）。根据<strong>能量守恒定律</strong>，几十亿人每天吃这么多，从食物链获取的能量不可能没有出口，否则得炸，只是到达了顶层食物链，人类产出就是自销和回归大自然，而GDP就是这些能量的记录，可想而知人类从自然界获取了多少能量。</p>
<p>纵观短短45年改革开放以来历史背景下的GDP变化，在宏观经济里，每个人都是无脸人，人群是没有智慧的，国家无形的手一松一紧，人群供需热情一松一紧，火车头往哪，车体就轰隆隆跟着走，每个人都是国家巨人的一块小肌肉，每个人只是一股力，巨人的目的是让GDP增长。世界环境动荡，永远也无法预测下一刻会发生什么，每个人只想日子过得好，而<strong>生活是永远不可能停下来的</strong>，因为物理世界里分子热运动，熵增不可改变，因此细胞一直在运动消耗能量，因此人活着需要能量和资源，因此大多数人希望经济发展来获得资源，经济发展需要适度的通货膨胀，通货膨胀让你不得不工作，而你停下来就找不到工作（笑死）</p>
<p>回到开始的问题，我将通过分析GDP总量和结构两方面对经济形势做一个粗糙的判断</p>
<p>分析GDP有两种角度，总量、结构</p>
<p><strong>从总量上</strong>，由于2023年的年度统计尚未发布，这里对季度数据进行分析，还有就是国家统计局网数据展示不够完善，这里直接就用了二层数据，直接看了macroview.club上的GDP同比增长折线图</p>


<p>图上显示，同比增长波动幅度最大是在2020年开始的疫情3年，直到现在才开始趋于稳定，而且同步增长率也低于疫情前，就连1997年的亚洲金融危机、2008年的全球金融危机等等历史大事件，也没有这次直接物理隔离停工停产造成的影响大，今年2023年时疫情恢复的第一年，还在回血期，确实是比以往更难。</p>
<p><strong>从结构上看</strong>，这里用的时国家统计局官网从2019年到2023年Q2的三次产业（不变价）贡献率图表展示，</p>


<p>疫情三年第三产业包括互联网行业不景气，第一、二产业异常飙升，产业结构动荡，产业贡献率直到今年才开始向第三产业服务业倾斜，希望能尽快恢复吧。19年以前的结构分析在下表展示的很到位，19年后的相同的图表统计没找到。</p>


<h4 id="物价CPI"><a href="#物价CPI" class="headerlink" title="物价CPI"></a>物价CPI</h4><p>CPI consumer price index，居民消费价格指数，度量居民生活消费品和服务价格随时间变动的相对数。CPI的统计方法，简单来说，是统计局先确定这时期哪些商品具有代表性，然后去调查价格做统计。CPI&#x3D;(现货价格指数&#x2F;基期价格指数)×100%</p>
<p>我国CPI每5年轮换一次基期，最近一次是2020年，相比于2015年，增减品类、权重等等，品类增加了外卖、母婴护理服务、新能源汽车、可穿戴智能设备、网约车费用等新兴产品，这5年变化可真大</p>
<p>都说物价上涨，那究竟涨了多少？还挺好奇的，于是查了东方财富网上的CPI数据</p>


<p>有两种方法，微观细致的分析预测有环比均值法高频数据法、宏观上可以从经济热度、货币政策等角度分析。精力有限就没再具体看，这里就直观的看这个走向，可以看到最近三年的CPI很不稳定，当前今年CPI指数很低近0，物价涨得慢说明供大于虚，从这能看出一点市场颓势吧。20-23年疫情三年CPI波动很大，大起大落的，供需关系、市场关系变化快，但总体物价还是会一直上涨</p>
<h4 id="财政数据"><a href="#财政数据" class="headerlink" title="财政数据"></a>财政数据</h4><p>这是个很有意思的角度，通过财政预算，可以看出当前财政中心和国家在哪方面经济支持力度如何，通过财政收入，可以看出当前经济运行情况，企业所得税、增值税体现企业经营情况，个人所得税看出当前就业收入情况，关税体现进口数据等</p>
<p>我国财政预算包括<strong>公共预算、政府性基金预算、国有资本经营预算、社会保险基金预算</strong>四类。</p>
<p>也是看书才知道，每年财政部都会在年初做好全国、中央和地方的预算表，每个月都会公布收支完成情况，年末会做一次总结。打开财政部的信息公开栏目里的财政数据，会发现每个月公布的数据里，除了月、季度的一般公共预算收支情况和政府性基金预算收支情况的公布，还会多出两个报告，<strong>国企经济运行情况、全国彩票销售情况</strong>。</p>
<p>what?!  彩票居然是国家发行的？国家居然有在发行彩票？而且还是财政部每个月都会公布销售量的部分，这算是国家的一个小彩蛋吗🍕个人分析其发行目的包括社会闲散资金再分配、无痛税收、解决就业、减少赌博迷彩犯罪等等，而且不止我们国家有，世界上很多国家都有在发行彩票。</p>
<blockquote>
<p>彩票市场产生于16世纪的意大利，从古罗马、古希腊开始，即有彩票开始发行。发展到今天，世界上已经有139个国家和地区发行彩票，规模比较大的国家有：美国、西班牙、德国、日本、法国、英国、意大利、加拿大、希腊、巴西、泰国、韩国、新加坡、印度等。</p>
<p>发行彩票集资可以说是现代彩票的共同目的。各国、各地区的集资目的多种多样，社会福利、公共卫生、教育、体育、文化是主要目标。以合法形式、公平原则，重新分配社会的闲散资金，协调社会的矛盾和关系，使彩票具有了一种特殊的地位和价值。</p>
<p>时至今日，彩票已成为世界第六大产业。</p>
</blockquote>


<p>再仔细看其中内容，以10月30日发布的9月份全国彩票销售情况为例，报告里说</p>
<blockquote>
<p>　9月份，全国共销售彩票527.74亿元[1]，同比增加194.42亿元，增长58.3%。其中，福利彩票机构销售182.13亿元，同比增加58.94亿元，增长47.9%；体育彩票机构销售345.61亿元，同比增加135.48亿元，增长64.5%。主要受亚运会等重大赛事增多、即开型彩票新票上市、新渠道拓展等因素影响，彩票销量较上年同期增长较快。</p>
</blockquote>
<p>说明我国<strong>彩票</strong>机构分成福利彩票机构和体育彩票机构，彩票类型又分成乐透数字、竞猜、即开、视频、基诺共5种，其中竞猜型市场份额近一半，乐透和即开型差不多，视频型相比为0.0</p>
<blockquote>
<p>常见的乐透数字型彩票有双色球、七星彩，竞猜型有足球、篮球体育竞猜，视频型彩票是新推出的票种，去年5月底海南省体育彩票管理中心宣布由中国体育彩票发行的首款视频电子即开游戏彩票上市，目前包括长城拼图、海南珍宝、足球三猜及赛马四款游戏</p>
</blockquote>


<p>让我们回到财政数据四本帐的分析上，上面提到，我国财政预算包括公共预算、政府性基金预算、国有资本经营预算、社会保险基金预算四类。四本帐里<strong>只有公共预算会出现赤字</strong>，政府性基金预算会以发行专项债的方式弥补缺口，因此一般债（财政赤字）+专项债就是今年预计市场会新发的政府债规模。</p>
<p>看到这里我就好奇如果我买了国债，那么<strong>国债什么时候偿还呢？</strong>查看对应文件，拿2022年12月08日财政部发布的关于《财政部2022年特别国债发行工作有关事宜的通知》，文件上是写明了发行目的、方式、利率、时间和兑付安排。至此国债在脑子里就不再是抽象的东西，他就是平时认知的借钱还钱。</p>
<blockquote>
<p>（五）兑付安排。本期国债按年支付，每年12月12日（节假日顺延）支付利息，2025年12月12日偿还本金并支付最后一次利息。财政部委托中央国债登记结算有限责任公司（以下称国债公司）办理利息支付及到期偿还本金等事宜。</p>
</blockquote>
<p><strong>一般公共预算</strong>，用与保障民生、维持国家机构正常运转、安全等，我理解为政府的主业。收入主要是税收收入，如增值税、消费税、印花税、环境保护税、车船税等，支出有基建类支出、民生类支出、债务支出。</p>
<p>在2019年全国一般公共预算支出项目中,占比靠前的分别是教育支出(14.57%)、社会保障和就业支出(12.3%)、城乡社区支出(10.42%)、农林水支出(9.57%)和一般公共服务支出(8.52%)</p>
<p><strong>政府性基金预算</strong>，我理解为政府的副业，听起来很抽象，但我一说具体内容你就清楚了。政府性基金收入包括国有土地使用权出让金、彩票公益金、港口建设费、旅游发展基金、国家电影事业发展专项基金等，国有土地使用权出让金和地方政府专项债卷收支占大头，其中让我意外的是单拎出个<strong>海南省高等级公路车辆通行附加费</strong>，在一众抽象的资金项目里瞩目。</p>
<blockquote>
<p>1994年，海南就在全国率先实行了公路规费征收模式改革，将“公路养路费、过桥费、过路费和公路运输管理费”四费合一为燃油附加费并统一在燃油销售环节价外征收。海南也由此成为全国唯一没有公路收费站卡的省份。</p>
<p>通行附加费征收标准几经调整，2011年确定为每升1.05元，并保持至今。</p>
<p>值得注意的是，海南新能源汽车事实上没有交纳通行附加费。据了解，目前海南新能源汽车保有量为3万多辆。海南省政府印发的《海南省清洁能源汽车发展规划》，明确提出海南在2030年起全面禁售燃油汽车。</p>
</blockquote>


<p><strong>国企经营预算</strong>收支占比很小，不到2%，收入就是各类国企（独资、控股、参股）的利润和股息，支出除了给自身经营，会直接补充给一般公共预算和社保基金里。</p>
<p><strong>社保基金预算</strong>，是只进不出的，也就是说青年朋友们交的社保费，只会用来给社保，不会用来基建、国企经营或者其他什么支出，这一点还挺合理的。</p>
<p>近年来的一个社会热点问题也是我非常好奇的一点，<strong>现在的社保资金还能够使用多久呢？</strong>未来我们会不会面临无社保可用的问题？这些可以通过社保基金账户的数据一窥究竟。比如未来的社保基金能用多久，我们可以根据现在的社保结余资金结合社保的历史支出节奏简单估算。</p>
<p>从收入端来看，社会保险基金收入可以分为保险费收入和财政补贴收入。</p>
<p><strong>保险费收入</strong>包括养老保险(68.3%)、医疗保险(29.2%)、工伤保险(1%)和失业保险(1.5%)。其中，养老保险可以进一步细分为机关事业单位、企业职工和城乡居民养老保险，医疗保险可以分为职工医疗和居民医疗。至于五险的生育保险和医疗保险合并了。</p>
<p><strong>财政补贴收入</strong>是一般公共预算补充给社保基金的，相当于国家财政对社保做的支持。近年社保基金收支缺口扩大，财政补贴占比加大，2020年补贴有2.1万亿元，对比2013年才7371亿元，压力山大呀。</p>
<p>从支出端看，养老支出占比最大，有近70%，医疗支出27%，大概是这么个情况。</p>
<p>由于<strong>社保基金是只进不出的</strong>，那多出来的钱就会存起来，每个省份的社保结余资金是不同的，像广东2019年就有结余1986亿元，滚存结余1.71万亿元，其中企业养老保险结余占大头，滚存结余1.17万亿元，OMG，也就是说企业打工人交的养老保险钱剩好多，看来目前广东年轻人还是养得起的老人，但有些省份就不太乐观🍐。不知道10年后又会怎样呢？</p>
<p>除了保险收入和补贴，还有个<strong>社会保障基金</strong>，这是国家为了应对人口老龄化高峰时期的养老保险等社会保障支出压力而设立的战略储备基金。其资金来源有中央财政预算拨款、国有资本划转、投资收益等。不同于社会保险基金（上面说的社保基金），这个是专门有个理事会去投资管理增值，以备不时之需的。</p>


<p>现在，我们来看今年3月28日财政部发布的今年一般公共预算里，排名靠前的主要是教育（15.3%）、社保就业（14.3%）、卫生健康（8.8%）和农林水事务（8.6%）等。纵向对比看，由于教育科技等支出较为刚性，医疗养老等民生相关支出负担不断增加，只能被迫缩减基建等资本性开支。</p>
<p>公共预算赤字率会下降，毕竟今年主打一个经济回血，税收会比去年高。具体其他的收支预算内容实在太多了，感兴趣的可以去财政部的中央预决算公开平台查看，总的来看就是落实过紧日子，当好“铁公鸡”、打好“铁算盘”，不该花的钱一分不花（官网写的）</p>


<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这次的宏观经济小分析就告一段落，能分析当前经济的数据指标实在很多，我只是从中挑选出比较感兴趣的三点就已经收获匪浅，前面的GDP带我复习了国内改革开放后经济发展历程，开了一只眼，CPI部分细节太多没再细看，最后看财政预算部分还有点在玩皇帝养成计划的错觉，其中学问大大滴。</p>
<p>从一开始”从哪里可以客观看出当前经济情况“这一个问题，借助了GDP、CPI和财政预算三个数据工具进行学习和实际分析，虽然并不专业，不够深入只是停留表面，但也是真能很明显看出疫情对经济的打击和今年经济复苏的不易，同时对这个世界的运行有了更加全面的认识，之前实在是陷在计算机世界里的井底之蛙，很遗憾21岁才弥补这些常识，以上都是我个人的浅薄见解和感受，还有太多要学习。</p>
<p>这里我参考的是李奇霖的《宏观经济数据分析手册》，想要更专业的解读可以看CMF最新发布的《中国宏观经济分析与预测报告》，这里附上一点摘要</p>
<blockquote>
<p>尽管各类数据已经证实，疫情政策优化之后的经济重启效应非常明显， 中国经济复苏已经开启，但不同于以往经济周期，在经历了三年疫情管控之后，本轮中国经济复苏需经历社会秩序与交易修复阶段、资产负债表修复阶段、常态化扩展阶段等三个不同阶段，而且在阶段转换上也可能会遭遇阻碍。当前中国经济复苏正处于从 第一阶段向第二阶段转换的关键期，这既是中国经济复苏的恢复性增长期，也是各种潜在风险显化和矛盾的集中爆发期。</p>
<p>经济复苏的痛点与难点集中表现为 “五个 20%”，即青年群体调查失业率突破 20%、工业企业利润总额同比下降 20%、 地方土地出让收入同比下降 20%、房地产新开工面积同比下降 20%、消费者信心 指数的缺口高达 20%。这“五个 20%”表明相关领域压力已经突破自我修复能力， 在宏观调控下集中治理好这“五个 20%”也就牵住了中国经济复苏的牛鼻子。</p>
<p>尽管上半年需求端和供给端都得到明显改善，但 CPI 涨幅的回落、PPI 跌幅的扩大、GDP 平减指数的全面回落都表明，需求端的恢复速度慢于供给端。 同时，青年群体失业率的逆势攀升，表明劳动力市场摩擦在进一步加剧，而在 出口波动和顺差扩大下，中国在全球产业链供应链地位发生了重大结构性变化。 </p>
</blockquote>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BB%8F%E6%B5%8E/" rel="tag">经济</a></li></ul>

    </footer>
  </div>

    
 
   
  
</article>

    
    <article
  id="post-捏泥人"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/10/28/%E6%8D%8F%E6%B3%A5%E4%BA%BA/"
    >捏泥人</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/10/28/%E6%8D%8F%E6%B3%A5%E4%BA%BA/" class="article-date">
  <time datetime="2023-10-28T03:01:55.000Z" itemprop="datePublished">2023-10-28</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%97%A0%E4%B8%AD%E7%94%9F%E6%9C%89/">无中生有</a>
  </div>
 
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  没有令牌不给进！ 
      <a class="article-more-link" href="/2023/10/28/%E6%8D%8F%E6%B3%A5%E4%BA%BA/"
        >阅读更多...</a
      >
       
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%A7%84%E5%88%92/" rel="tag">规划</a></li></ul>

    </footer>
  </div>

    
 
   
  
</article>

    
    <article
  id="post-我炼黄金丹之JAVA进阶"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/10/20/%E6%88%91%E7%82%BC%E9%BB%84%E9%87%91%E4%B8%B9%E4%B9%8BJAVA%E8%BF%9B%E9%98%B6/"
    >我炼黄金丹之JAVA进阶</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/10/20/%E6%88%91%E7%82%BC%E9%BB%84%E9%87%91%E4%B8%B9%E4%B9%8BJAVA%E8%BF%9B%E9%98%B6/" class="article-date">
  <time datetime="2023-10-20T02:18:17.000Z" itemprop="datePublished">2023-10-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%90%8E%E5%A4%87%E7%AE%B1/">后备箱</a>
  </div>
 
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <blockquote>
<p>引言：随着项目基础完成并不断完善，不再满足与基础知识，对于应用场景下要考虑的并发问题、框架底层认识问题都推动着我继续学习下去。</p>
</blockquote>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>书籍： <a href="C:\Users\Lin\Desktop\实习\净莲妖火\仓库\Java并发编程艺术.pdf">Java并发编程艺术.pdf</a> </p>
<blockquote>
<p>Java并发机制的底层实现原理</p>
</blockquote>
<p>cpu到memory之间，还有L1、L2、L3 cache，cache放在cpu处理器里头，以我的电脑配置为例，有一个插槽即一个物理cpu芯片，6个内核即把cpu分成了6个独立运行单元，12个逻辑处理器即每个内核利用超线程技术分成两个逻辑内核，也就是说，我的电脑cpu允许12个线程并行运行。一个核是一个可以运行指令的独立单元，它包含了ALU和寄存器，并配备L1和L2 Cache。多个核心共享L3 Cache。</p>
<p>volatile的理解和之前并无差别，就是读写都从内存里获取，用总线通知并行计算的内核单元要同步，但仍然无法保证线程安全、原子性操作</p>
<p>synchronized，锁升级机制，偏向锁、轻量级锁、重量级锁</p>
<p><strong>Java中实现线程同步方法</strong></p>
<p>Java底层原子操作的方式：循环CAS，锁。而除了偏向锁，其他锁的获取和释放都使用了循环CAS。JVM实现CAS是直接使用处理器上的原子操作指令实现的</p>
<p>但Java已经封装好了一些同步方法可以即时用：Synchronized关键字|可重入锁，并发包下线程安全的集合，同步策略如生产者消费者模型</p>
<p><strong>Java中线程间的通信方式</strong></p>
<p>总的来说有两种，共享变量和直接通信</p>
<p>使用共享变量，可以采用volatile关键字保证变量的可见性，或使用synchonized等锁同步机制保证变量的正确</p>
<p>直接通信，包括使用对象的wait&#x2F;notify方法，管道读写流，socket网络通信，Thread.join()本质也采用wait&#x2F;notify</p>
<p><strong>Java中创建多线程的方法</strong></p>
<p>最直接的，继承thread类。要想父子线程任务解耦，可以实现runnable接口，如果希望获取子线程运行结果，可以使用实现callable接口，放进future task包装器里获取。也可以使用线程池提交任务的方法实现</p>
<blockquote>
<p>Java内存模型</p>
</blockquote>
<p>发觉许多处，如讲述JMM里线程怎么通过共享内存的方式进行通信，会涉及到在计算机系统结构课里学过的内容。之前看完Java再去复习操作系统，会有共鸣，现如今居然又和系统结构串联起来，十分奇妙，像是萧炎在初期服丹药运斗气洗筋脉，把原本杂乱扭曲狭窄的筋脉活络疏通，将原本碎片化分布成的淤血震碎重塑，斗气运转起来。</p>
<p>整个concurrent包实现的基石，是用<strong>volatile变量的读&#x2F;写+CAS实现线程间的通信</strong>。</p>
<p>如果我们仔细分析 concurrent 包的源代码实现，会发现一个通用化的实现模式。 </p>
<p>首先，声明共享变量为 volatile。 然后，使用 CAS 的原子条件更新来实现线程之间的同步。 同时，配合以 volatile 的读&#x2F;写和 CAS 所具有的 volatile 读和写的内存语义来实现线 程之间的通信。</p>
<p>JUC的实现框架如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph BT</span><br><span class="line">	a[volatile变量的读写 CAS] --&gt; b[AQS 非阻塞数据结构 原子变量类]</span><br><span class="line">	b --&gt; c[Lock 同步器 阻塞队列 Executor 并发容器]</span><br></pre></td></tr></table></figure>

<p>对于内存可见性和volatile、锁、final内存语义上没有做了解，太深了…</p>
<blockquote>
<p>Java 并发编程基础</p>
</blockquote>
<p>仔细研究给出的DefaultThreadPool.java代码，可以抠出不少东西，包括子类worker实现runnable接口实现run、shudown方法，worker线程间共享堆中的jobs对象，联想到<strong>线程私有和共有资源都有哪些，使用jobs的wait&#x2F;notify机制实现同步控制，synchronized同步代码块参数是什么意思，不用spring怎么实现单例模式</strong>，半吊子看这本书会疯魔，理解一句话要查各种资料缝补</p>
<p>Socket 是对 TCP&#x2F;IP 协议的封装，Socket 只是个接口不是协议，通过 Socket 我们才能使用 TCP&#x2F;IP 协议，除了 TCP，也可以使用 UDP 协议来传递数据。创建 Socket 连接的时候，可以指定传输层协议，可以是 TCP 或者 UDP。通过socket建立传输层连接后，接着获取http报文进行业务处理，传输层底下是网络层的IP协议</p>
<p><strong>孤儿进程</strong>，父进程结束但子进程还活着，子进程资源将有init进程回收，危害不大。<strong>僵尸进程</strong>，父进程在运行但子进程已死，但父进程没有wait()回收进程号，会导致系统进程号耗尽，相当于一个进程一直在创建进程却不回收进程号，解决方法，杀死父进程让init进程回收、父进程wait()阻塞等待子进程、利用信号机制，子进程死之前调用kill(int pid, int SIGCHID)发送信号SIGCHLD，内核给一个进程发送软中断信号的方法，是在进程所在的进程表项的信号域设置对应于该信号的位。父进程调用signal(SIGCHLD,sig_child)非阻塞等待，在信号处理函数sig_child()中调用wait进行处理僵尸进程。什么时候得到子进程信号，什么时候进行信号处理，父进程可以继续干其他活，不用去阻塞等待。内核处理一个进程收到的信号的时机是在一个进程从内核态返回用户态时。所以，当一个进程在内核态下运行时，软中断信号并不立即起作用，要等到将返回用户态时才处理。</p>
<p><strong>main线程死亡，并不影响其他线程继续运行</strong>，main线程是由java虚拟机在启动的时候创建的，它不是守护线程。java虚拟机(相当于进程)退出的时机是：虚拟机中所有存活的线程都是守护线程。只要还有存活的非守护线程虚拟机就不会退出，而是等待非守护线程执行完毕</p>
<p>thread.interrupt，好比其他线程对该线程打了个招呼，中断可以理解为线程的一个标识位属性，它表示一个运行中的线程是否被其他线程进行了中断操作，是一种简便线程间交互方式</p>
<h2 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h2><p>书籍： <a href="C:\Users\Lin\Desktop\实习\净莲妖火\仓库\一本小小的MyBatis源码分析书.pdf">一本小小的MyBatis源码分析书.pdf</a> </p>
<p>MyBatis是一个国外开源的，半自动化的ORM持久化层框架</p>
<p>MyBatis-Plus是国内苞米豆团队在MyBatis基础上扩展功能后的开源框架</p>
<p>半自动化，因为仍然需要手写sql语句，相对于自动生成sql的全自动化框架Hibernate，是半自动化的</p>
<p><strong>相比于直接使用JDBC，MyBatis帮我们做了什么事情？</strong></p>
<ol>
<li>数据库连接等准备工作的配置，直接用sqlSessionFactory创一个sqlSession后，就可以一直调用这个单例sqlSession操作数据库，而底层的数据库连接池管理，由MyBatis做</li>
<li>把sql代码和java代码分离</li>
<li>自动映射sql结果到对象里头，手动加入也太丑了吧！</li>
</ol>
<p><strong>MyBatis编程步骤</strong></p>
<p>1、创建SqlSessionFactory 2、通过SqlSessionFactory创建SqlSession  3、 通过sqlsession执行数据库操作 4、 调用session.commit()提交事务 5、 调用session.close()关闭会话</p>
<p><strong>MyBatis缓存机制</strong></p>
<p>它居然也有缓存？这是我没想到的！</p>
<p>MyBatis 缓存结构由一级缓存和二级缓存构成，这两级缓存均是使用 Cache 接口的实现类。</p>
<h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><p>书籍： <a href="C:\Users\Lin\Desktop\实习\净莲妖火\仓库\SpringBoot揭秘快速构建微服务体系.pdf">SpringBoot揭秘快速构建微服务体系.pdf</a> </p>
<blockquote>
<p><strong>碎碎念</strong></p>
<p>原来annotation并不是spring的，是Java本身就自带的一种代码形式！常见的@override就是一个！对比c++的attribution好看有简洁，很干净，爱了爱了</p>
<p><strong>Spring</strong></p>
<p>自动配置：重新审视spring中实现IOC自动化装配的两大机制，理解是自然而然的，要实现对象在整个项目里的单例，首先要先扔进容器里，那么<strong>组件扫描</strong>、@Autowired<strong>自动装配</strong>是必须的，创建一个组件并使用@component把他扔进容器里，接着启动@ComponentScan对当前包及子包下所有艾特component的进行扫描，创建单例，对于那些无法单独存在，需要依赖容器里其他组件的小子，只需要在代码里加入@Autowired即可。</p>
<p>显示配置：分为两种方法，直接用Java写配置类、用Xml写配置</p>
<p>JavaConfig方法：创建<strong>配置类</strong>，用**@Configuration<strong>注解上，@Configuration注解表明这个类是一个配置类，该类应该包含在Spring应用上下文中如何创建bean的细节，接着在配置类里写方法并加上@Bean注解，</strong>@Bean<strong>注解会告诉Spring这个</strong>方法<strong>将会</strong>返回一个对象**，该对象要注册为Spring应用上下文中的bean。方法体中包含了最终产生bean实例的逻辑。</p>
<p>而这段话，在自动配置里只用@component就ok</p>
</blockquote>
<p><strong>模板化的启动过程</strong></p>
<p>springboot主要就是要做到快速开发，提供开发者开箱即用的配件，包括一键启动，以及starter预制包</p>
<p>springboot的自动装配：其实就是@SpringbootApplication下的@EnableAutoConfiguration借助SpringFactoriesLoader把所有@Configuration的类都加载到IOC容器里，其实就是Springboot提前写好了一些配置类，然后扫描即可</p>
<p>springboot的启动流程：初始化springApplication类，执行springApplication类的run方法，包括初始化初始化器、监听器，准备上下文环境，加载bean，最后装填完毕</p>
<blockquote>
<p>reactive web：</p>
<p>在初始化过程中，WebApplicationType.deduceFromClasspath()是负责推断当前项目是什么类型的。目前springboot支持servlet、reacitve两种web应用，前者是命令式编程，使用MVC的单线程阻塞模式进行网络请求处理，响应量弱。后者是响应式编程，以事件驱动形式，利用reactor模式实现异步非阻塞处理，提高吞吐量，但业务处理仍然使阻塞，不能缩短处理时间。</p>
<p>spring的事件监听机制：</p>
<p>启动过程主要就在操作 initializer、listener、loader，那么listener们究竟是做什么的呢？查看上面的引用链接，会发现这种事件的发布监听机制，其实是spring惯用的方法，用于调用和结果监听解耦。</p>
</blockquote>
<h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><p>书籍：<a href="D:\文件集\大狗\three_one\大数据技术基础\大数据技术基础第二讲.pptx">大数据技术基础第二讲.pptx</a> </p>
<p>消息队列，用来解耦生产者消费者，缓冲彼此处理速度差</p>
<p><strong>基础架构</strong></p>
<p>kafka，由三个组件producer、broker、consumer组成，采取push-pull的方式进行消息的发布和订阅。broker里分成不同topic，每个topic里通过对key值哈希取模分成不同partition，因为kafka是分布式消息队列，不同broker上会存放冗余partition，同一时刻只有一个partition对外服务，其他的只是备份。</p>
<p><strong>工作流程</strong></p>
<p>producer把message、topic、key发送给broker，broker根据topic存放，并计算key的哈希取模存放message到partition里，broker写入磁盘并自动进行负载存储，consumer需要的时候向broker提供起始offset，broker将消息获取并提供给consumer</p>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p><strong>存储逻辑架构</strong></p>
<p>redis，就是一个字典，由hash表实现，每个目录项是每个dictEntry，这个入口包含key、value指针和指向下一个目录项的指针。key值存储在redis自定义的结构体SDS中，比直接用c语言的String多出了字符串长度、剩余长度，能有效扩容，快速查询长度。redis里数据类型有常用的String类型，以及数据集类型(List、Hash、set、zset)，因为数据集类型不能自动删除集合内元素，项目里直接采用了String类型。数据集类型中，Hash的单个元素存kv，其他三个只存v，List是个双向列表，实现队列、栈，set是无序集合、zset是有序集合</p>
<p><strong>持久化机制</strong></p>
<p>为了让redis在宕机后快速恢复数据，需要有持久化机制把数据快照&#x2F;执行语句记录下来，类似于mysql中的binlog。方式有两种，RDB和AOF</p>
<p>RDB，有阻塞save和非阻塞bgsave两种方式，bgsave就是fork一个子进程存下数据快照这种方式备份、恢复速度快，但丢失数据较多</p>
<p>AOF，记录的是执行命令。在 AOF体积变得过大时，子进程对 AOF进行语句压缩重写，重写过程中主进程会产生新的命令，这些命令先放在AOF重写缓存中，子进程写完AOF文件后，再把重写缓存中追加进去</p>
<p><strong>集群监控</strong></p>
<p>主从复制：为解决单点故障，实现高可用</p>
<p>为了监控主从节点正常运行，使用哨兵机制进行集群监控。每个哨兵每隔一段时间ping一次节点，超时未收到回复则认为主观下线，如果是主节点被认为主观下线，询问其他哨兵是否也认为主观下线，认为数量超过阈值，判定为客观下线，选举新的主节点，一旦选举成功，其他从节点同步主节点上信息</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/" rel="tag">JAVA</a></li></ul>

    </footer>
  </div>

    
 
   
  
</article>

    
    <article
  id="post-擦去阳光照射下的灰尘"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/10/14/%E6%93%A6%E5%8E%BB%E9%98%B3%E5%85%89%E7%85%A7%E5%B0%84%E4%B8%8B%E7%9A%84%E7%81%B0%E5%B0%98/"
    >擦去阳光照射下的灰尘</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/10/14/%E6%93%A6%E5%8E%BB%E9%98%B3%E5%85%89%E7%85%A7%E5%B0%84%E4%B8%8B%E7%9A%84%E7%81%B0%E5%B0%98/" class="article-date">
  <time datetime="2023-10-14T07:47:00.000Z" itemprop="datePublished">2023-10-14</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E4%BF%AE%E7%82%BC%E6%97%A5%E5%BF%97/">修炼日志</a>
  </div>
 
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>昨夜我梦见了一个遗憾，它像此时窗边照进来的太阳，叫我用指腹擦去键盘上发光的灰尘</p>
<p>或许这就是我，每到一个真空期，一直牵引我的感觉会在某一天某一刻，让我停下来打点记录，时间流逝，而我将永远追随它</p>
<p>奋力奔跑的这半年，我爱上了奔跑，爱上了摇滚和自由</p>
<p>我喜欢纯粹，如同我的衣服更多的是纯色系，做事喜欢工整，杂乱的情绪让我崩溃，不时会停下修正身上的羽毛，因此删去碎片化软件的这三个月，我找到了生活的节奏，凝神静心地投入生活缝补感受，是无比幸福的。</p>
<p>当然纯色衣服是无聊的，所以偶尔我也会有炫丽疯狂的需求，给生活点缀上彩色花瓣</p>
<p>每个人都有自己的生活rhyme，或许是流行芭乐，雷鬼轻快，或是优雅爵士，而我在这段时间里找到了属于我的节奏，热烈摇滚。金属摇滚在我最困难的时候鼓舞了我，歌曲里有力的鼓点和生命力像一只壮硕的手臂把我从地上拉起，一起跳舞。</p>
<p>自学Java的三个月里，我有点喜欢上了写代码，我喜欢成果带来的成就感，即使它是摸不到的、复杂的，但这也算是新开辟的一种感受，不同于感官感受，思维感受没有强烈快感，就像和一个沉默不言的老头聊天，未来某一天才会收获感受果实，但后劲更强。</p>
<p>因为计算机世界里，要学习的东西很多，走着走着你总会遇到意料不到的观点，撬动你的认知，原来是这样子啊，或者你艰难走过一段路，再回头走一次，两次直到熟悉，哦，原来是这样子啊，就是这么神奇。</p>
<p>很久没有感受到人间烟火气了，忙碌的北京唯独缺少这件玩意</p>
<p>钢琴声静悄悄的，可我不想让我的生活也轻悄悄的</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%84%9F%E6%82%9F%E6%BB%9A%E5%AD%98/" rel="tag">感悟滚存</a></li></ul>

    </footer>
  </div>

    
 
   
  
</article>

    
    <article
  id="post-我炼黄金丹之JAVA诞生"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/10/06/%E6%88%91%E7%82%BC%E9%BB%84%E9%87%91%E4%B8%B9%E4%B9%8BJAVA%E8%AF%9E%E7%94%9F/"
    >我炼黄金丹之JAVA诞生</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/10/06/%E6%88%91%E7%82%BC%E9%BB%84%E9%87%91%E4%B8%B9%E4%B9%8BJAVA%E8%AF%9E%E7%94%9F/" class="article-date">
  <time datetime="2023-10-06T08:45:37.000Z" itemprop="datePublished">2023-10-06</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%90%8E%E5%A4%87%E7%AE%B1/">后备箱</a>
  </div>
 
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="JAVA基础"><a href="#JAVA基础" class="headerlink" title="JAVA基础"></a>JAVA基础</h2><p>起始：2023-5-10，2023-7-23</p>
<p>书籍： <a href="Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B71(%E7%AC%AC10%E7%89%88).pdf">Java核心技术卷1(第10版).pdf</a> </p>
<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><ul>
<li>什么是多态？<ul>
<li>从面向对象思想来看，多态是指一个对象具有多种表现形态</li>
<li>具体在JAVA中，体现在，父类或接口可以引用子类或实现类</li>
<li>在实现上分为静态多态和动态多态<ul>
<li>静态多态是说方法重载，这个方法在编译时已经能够确定，同时这个方法名下有不同的方法签名和实现。</li>
<li>动态多态是说方法重写，在编译时无法根据方法签名确定子类使用的方法，需要在运行时根据具体的子类确定。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h3><ul>
<li><p>官方文档</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/">Java Platform Standard Edition 8 Documentation (oracle.com)</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/guides/lang/index.html">The java.lang and java.util Packages (oracle.com)</a></li>
</ul>
</li>
<li><p>split、trim和join都是String class里的方法，String class包装在java.lang里</p>
</li>
<li><p>reverse是Collections class里的static方法，集合包装在java.util里</p>
</li>
<li><p>stack是类，queue是接口，实现它的有链表LinkedList和prorityqueue</p>
</li>
</ul>
<h3 id="核心技术卷1"><a href="#核心技术卷1" class="headerlink" title="核心技术卷1"></a>核心技术卷1</h3><p>很明显，在阅读这本书之前，这些方法没用过，向高级JAVA进阶！</p>
<p>强类型语言是一种强制类型定义的语言，即一旦某一个变量被定义类型，如果不经强制转换，那么它永远就是该数据类型。而弱类型语言是一种弱类型定义的语言，某一个变量被定义类型，该变量可以根据环境变化自动进行转换，不需要经过现行强制转换。</p>
<p>java是强类型语言</p>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><ul>
<li>Java中数据类型分两种，基本数据类型、引用类型</li>
<li>在Java中，字符串类型（String）是基于char数组实现的，其长度受到Java虚拟机（JVM）对对象大小的限制。具体来说，字符串的长度不能超过Integer.MAX_VALUE，即2^31-1（约为2.14亿）个字符。</li>
<li>在解决大数问题上，可以使用字符串&#x2F;数组来表示大数，因为相当于string是2亿位数，而计算机最多位的基本类型long只有64位，相当于string能存储任意长度数字，而且string的2个空就可以存99，到int里哪止啊</li>
</ul>
<h4 id="FOR循环"><a href="#FOR循环" class="headerlink" title="FOR循环"></a>FOR循环</h4><ul>
<li><p>for循环的括号内(1; 2; 3)执行顺序：1-&gt;2-&gt;满足2条件，则执行大括号，否则跳出循环</p>
<p>-&gt;(3-&gt;2-&gt;满足2条件，则执行大括号，否则跳出循环)…</p>
</li>
<li><p>在for循环内创建的对象是在堆内存中创建的，创建的变量是在栈内存中创建的，每执行完一次循环，JAVA的垃圾回收机制就会检查哪些对象或变量是废弃的、不再使用的(比如，每循环一次创建一个链表节点，那么每个节点因为会被上一个节点引用，因此不是废弃的，故循环结束后仍然存在)，对于废弃节点将回收内存空间</p>
</li>
</ul>
<h4 id="对象和类"><a href="#对象和类" class="headerlink" title="对象和类"></a>对象和类</h4><ul>
<li><p>隐式参数&amp;显示参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">raiseSalary</span><span class="params">(<span class="type">double</span> byPercent)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">double</span> <span class="variable">raise</span> <span class="operator">=</span> salary * byPercent / <span class="number">100</span>;</span><br><span class="line">	salary += raise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>方法有两个参数，第一个是没有声明的employee类对象，称隐式参数，yinyong第二个是括号中的数值，称显示参数</p>
</li>
<li><p>关键字this表示隐式参数</p>
</li>
</ul>
</li>
<li><p>Java 方法都是值传递</p>
<ul>
<li>参数传递包括基本类型传递和对象引用传递</li>
<li>对象引用传递是对原对象的<strong>引用</strong>进行拷贝，两个引用都指向一个对象，因此能做到在函数中修改原对象，但这个引用的传递，依旧是值传递</li>
</ul>
</li>
<li><p>静态域-static</p>
<ul>
<li><p>对每个static对象或数据，所有对象共享一个不可修改的静态域，静态域属于类，不属于任何对象，如nextid</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">nextld</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>静态方法</p>
<ul>
<li>建议使用类名， 而不是对象来调用静态方法</li>
<li>如Math.pow(x, a)就是一个静态方法</li>
<li>在下面两种情况下使用静态方法：<ul>
<li>不需要访问对象状态，其所需参数都是通过显式参数提供（例如：Math.pow)</li>
<li>只需要访问类的静态域（例如：Employee.getNextld)</li>
</ul>
</li>
<li>静态嘛，不需要每个对象都拷贝一遍，省空间咯，还直白直观</li>
<li>main 方法也是一个静态方法哦</li>
</ul>
</li>
<li><p>函数式接口</p>
<p><strong>函数式接口</strong>定义 一个接口有且只有一个抽象方法。 函数式接口的实例可以通过 lambda 表达式、方法引用或者构造方法引用来创建。</p>
</li>
</ul>
<h4 id="集合🐾"><a href="#集合🐾" class="headerlink" title="集合🐾"></a>集合🐾</h4><blockquote>
<p>🔎阅读源码</p>
</blockquote>
<ul>
<li><p>关系图：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_67322837/article/details/124322953">Java集合框架详解</a></p>
</li>
<li><p>刷题碰到双栈实现队列，如果使用Stack解，速度很慢</p>
<p>Java中实际上提供了java.util.Stack来实现栈结构，但官方目前已不推荐使用，而是使用java.util.Deque双端队列来实现队列与栈的各种需求。</p>
<p>原因：Stack继承了Vector接口，而Vector底层是一个Object[]数组，那么就要考虑空间扩容和移位。使用LinkedList来做Stack的容器，因为LinkedList实现了Deque接口，所以Stack能做的事LinkedList都能做，其本身结构是个双向链表，扩容消耗少。</p>
</li>
<li><p>刷题碰到这行代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br></pre></td></tr></table></figure></li>
</ul>
<p>两个问题：</p>
<ul>
<li><p>为什么左边的接口对象能 &#x3D; 右边的句柄？</p>
<p>Deque接口由LinkedList和ArrayDeque实现，这里是<strong>面向接口编程</strong>的思想。面向接口编程是面向对象的重要思想组成，是JAVA中多态的一种体现</p>
</li>
<li><p>因为是要动态添加删除，所以用List，但为什么<strong>不用数组ArrayList而用链表LinkedList</strong>呢？</p>
<p>原因就是链表中间插入删除更加便捷高效。加说一句，JAVA中的LinkedList节点指向前、后面。</p>
<p>ps：这个问题还是在网上博客里无意瞄到的，看来大家都是看过技术卷的人呐🫠</p>
</li>
<li><p>双括号初始化</p>
<ul>
<li><p>做题碰到题解这么写，这样的构造和初始化方法没见过，根据技术卷说，这是使用了内部类的语法，第一个括号构造了一个继承hashmap的匿名子类，第二个括号是该类的实例初始化块(非静态初始化块)。</p>
</li>
<li><p><u>创建使用匿名内部类格式：父类 对象 &#x3D; new 父类（）{  重写父类中的方法  }</u></p>
</li>
<li><p><u>实例初始化程序块</u>用于初始化实例数据成员。 它在每次创建类的对象时运行。</p>
<p>完全可以直接放进构造函数里，而实际编译时也是放进构造函数里的，降低可读性，不过这样直接创建匿名内部类的初始化方法还是挺好用的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bike7</span> &#123;</span><br><span class="line">    <span class="type">int</span> speed;</span><br><span class="line"></span><br><span class="line">    Bike7() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;speed is &quot;</span> + speed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        speed = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">Bike7</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bike7</span>();</span><br><span class="line">        <span class="type">Bike7</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bike7</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>因为这里的每个map到后面不再需要，通过map[]可直接索引，因此这里用匿名类很合适很简洁，最后我们通过new得到hashmap的子类的实例化，然后<strong>上转型</strong>为hashmap的引用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map[] states = &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;() &#123;&#123; put(<span class="string">&#x27; &#x27;</span>, <span class="number">0</span>); put(<span class="string">&#x27;s&#x27;</span>, <span class="number">1</span>); put(<span class="string">&#x27;d&#x27;</span>, <span class="number">2</span>)&#125;&#125;, <span class="comment">// 0.</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;() &#123;&#123; put(<span class="string">&#x27;d&#x27;</span>, <span class="number">2</span>); put(<span class="string">&#x27;.&#x27;</span>, <span class="number">4</span>); &#125;&#125;,            <span class="comment">// 1.</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;() &#123;&#123; put(<span class="string">&#x27;d&#x27;</span>, <span class="number">2</span>); put(<span class="string">&#x27;.&#x27;</span>, <span class="number">3</span>); put(<span class="string">&#x27;e&#x27;</span>, <span class="number">5</span>);&#125;&#125;, <span class="comment">// 2.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>length——数组的属性</p>
<p>length()——String的方法</p>
<p>size()——List集合的方法</p>
</li>
<li><p><strong>HashCode</strong>是为了配合哈希表对元素做的一个映射。对于set和map来说，通常要求不重复，当有一个新元素来，如果是遍历查重比对，需要O(n)，而java中利用了哈希表，把相同HashCode的元素放在同一个桶里，初步筛选后再用equals()做比对查重。**通常要求重写equals()，也要重写hashcode()**，因为如果相同元素放在了不同桶里，就不能用equals()比对了。因此Hashcode()的作用就是把元素放在正确的桶里</p>
</li>
<li><p>工具类</p>
<ul>
<li>Array &amp; Arrays || collection &amp; collections</li>
<li>Arrays、collections是工具类，无法实例化，有很多静态方法提供给数组、集合使用</li>
<li>collections中有许多封装好的算法，如sort、shuffle、binarySearch、min&#x2F;max、两集合是否有公共元素，是多少等等</li>
<li>collection是集合接口</li>
</ul>
</li>
<li><p>Java集合框架</p>
<ul>
<li><p>Java中集合框架包括两大接口 collection 和 map</p>
</li>
<li><p><strong>collection</strong>存储单一元素，具体有 List、set、queue</p>
</li>
<li><p><strong>map</strong>存储键值对，具体有hashMap、hashTable、treeMap</p>
</li>
<li><p>List：有序可重复 ，set：无序不重复，queue：队列</p>
</li>
<li><p>hashMap更快，treeMap会对节点根据键排序，组织成搜索树</p>
</li>
<li><p><strong>List</strong></p>
<ul>
<li><p>底层数据结构</p>
<ul>
<li>ArrayList: object[]</li>
<li>LinkedLIst: implements List, Deque</li>
<li>Vector: object[]</li>
</ul>
</li>
<li><p>ArrayList和LinkedList区别</p>
<ul>
<li><p>数据结构：ArrayList基于object数组，LinkedList基于双向链表实现</p>
</li>
<li><p>插入、删除、查询的时间复杂度：</p>
<p>ArrayList查询为o(1)，不需要扩容时，插入尾部为o(1)，其他位置插删为o(n)，需要扩容时插入尾部为o(n)</p>
<p>LinkedList查询为o(n)，头尾的插删为o(1)，中间位置的插删平均为o(n)</p>
</li>
<li><p>内存空间占用：LinkedList每个元素都会比ArrayList多前后引用的额外占用，ArrayList的数组则会在末尾留出一定的空间</p>
</li>
</ul>
</li>
<li><p>📌ArrayList扩容机制</p>
<p>默认无参构造的ArrayList初始扩容为10，容量超过目前数组长度时，需要进行扩容，默认扩容原始长度一半(&gt;&gt;1)，底层调用的是Arrays.copyOf进行扩容。</p>
</li>
</ul>
</li>
<li><p><strong>Set</strong></p>
<ul>
<li>底层数据结构<ul>
<li><p>HashSet: HashMap&lt;E,Object&gt; ，无序(数据存储顺序和输入顺序不同，因为数据是根据hashCode放进Map里，遍历map输出数据你会发现和输入顺序不同)，唯一(存在hashMap键里，至于HashMap是怎么做到键值唯一，就是先比较hashcode，如果相同再调用equal，具体看上面为什么改了equal就要改hashcode部分)</p>
</li>
<li><p>TreeSet: NavigableMap&lt;E,Object&gt;，有序(NavigableMap继承sortedmap，由红黑树自动排序)，唯一(存在map键里)</p>
</li>
<li><p>HashSet、LinkedHashSet、TreeSet三者异同</p>
<p>都实现set接口，元素唯一，且线程不安全</p>
<p>区别在于底层数据结构，HashSet是基于HashMap实现，是无序的，无法做到FIFO，LinkedHashSet比HashSet多了一个双向链表用于满足插入取出FIFO，TreeSet基于的是红黑树，元素有序，排序规则可以自定义</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Queue</strong></p>
<ul>
<li><p>首先看Queue接口，源码已经写得很清楚，对于增加、删除、查看元素都有two forms，一种失败了会抛异常(add, remove, element)，一种只是返回值(offer,poll,peek)，仔细品两种的名字会觉得很贴切，前者给人感觉是强制的我只看结果，后者只是提供给你只是拉数据出来没有清除这种直接针对结果的强制感，peek也只是偷瞄，设计者蛮用心</p>
</li>
<li><p>继承Queue的Deque接口也是有两种forms</p>
</li>
<li><p>底层数据结构</p>
<ul>
<li>PriorityQueue: Object[]，数组实现平衡二叉堆，元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。</li>
<li>ArrayDeque: Object[]+双指针(指向头尾)，和ArrayList区别<strong>因为有双指针</strong>所以ArrayDeque不能存<strong>null</strong></li>
<li>LinkedList: Node&lt;E&gt; 链表+双指针(指向头尾)，可以有null</li>
</ul>
</li>
<li><p>实现队列来说，也是ArrayDeque比LInkedList性能更好(Link兄弟&#x2F;(ㄒoㄒ)&#x2F;~~)，ArrayList类似，ArrayDeque也需要扩容，但LinkedList每次插入数据时均需要申请新的堆空间，性能慢</p>
</li>
</ul>
</li>
<li><p><strong>Map</strong></p>
<ul>
<li><p>底层数据结构</p>
<ul>
<li><p>HashMap: Node&lt;K,V&gt;[]</p>
<p>Node&lt;K,V&gt;是内部类相当于一个链表(“拉链法”解决哈希冲突)，在JDK1.8之后，解决哈希冲突不仅是”拉链法”，当链表长度大于阈值(8)，同时数组长度小于阈值(64)，那么会选择先进行数组扩容，若数组长度超过64，就把链表转换为红黑树，从而解决链表过长问题，以减少搜索时间</p>
<blockquote>
<p>TreeMap、TreeSet 以及 JDK1.8 之后的 HashMap 底层都用到了红黑树。红黑树是用来提高查找性能的，因为二叉查找树在某些情况下会退化成一个线性结构。</p>
</blockquote>
</li>
<li><p>LinkedHashMap: Entry&lt;K,V&gt; &#x3D; Node&lt;K,V&gt;[] + Entry&lt;K,V&gt; before, after，继承HashMap，仍然使用数组+拉链&#x2F;红黑树，每个节点多加了一个double方向，用于指明插入顺序</p>
</li>
<li><p>Hashtable: Node&lt;K,V&gt;[]，hashtable不允许v为null，hashmap允许</p>
<p>不过它基本被淘汰，不要在代码中使用它；</p>
<blockquote>
<p>Hashtable class implements a hash table, which maps keys to values. Any non-null object can be used as a key or as a value.</p>
<p>“ put method : </p>
<p>&#x2F;&#x2F; Make sure the value is not null<br>if (value &#x3D;&#x3D; null) {<br>    throw new NullPointerException();<br>}  “</p>
<p>The HashMap class is roughly equivalent to Hashtable, except that it is unsynchronized and permits nulls.</p>
</blockquote>
</li>
<li><p>TreeMap: Entry&lt;K,V&gt;，节点链起来的一颗红黑树</p>
<p>TreeMap比HashMap多实现了两个接口，实现 NavigableMap 接口让 TreeMap 有了对集合内元素的搜索的能力。实现SortedMap接口让 TreeMap 有了对集合中的元素根据键排序的能力。</p>
<blockquote>
<p>A Red-Black tree based NavigableMap implementation. The map is sorted according to the natural ordering of its keys, or by a Comparator provided at map creation time, depending on which constructor is used.</p>
<p>“ static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {<br>    K key;<br>    V value;<br>    Entry&lt;K,V&gt; left;<br>    Entry&lt;K,V&gt; right;<br>    Entry&lt;K,V&gt; parent;<br>    boolean color &#x3D; <em>BLACK</em>;</p>
<p>} “</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>HashMap初始容量、扩容大小</p>
<ul>
<li>不指定大小，HashMap 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。</li>
<li>创建时如果给定了容量初始值，HashMap 会将其扩充为 2 的幂次方大小</li>
</ul>
</li>
<li><p>为什么是数组长度要是2的幂次方？</p>
<p>hash值映射到当前数组长度，需要取余，hash % length，为了提高运算效率，如果length是2的幂次方，hash % length &#x3D;&#x3D; hash &amp; (length -1)，在源码中也确实是这么干的</p>
<blockquote>
<p>int index &#x3D; (n - 1) &amp; hash;</p>
</blockquote>
</li>
<li><p>为什么HashMap线程不安全？</p>
<p>JDK1.7 及之前版本，在多线程环境下，HashMap 扩容时会造成死循环和数据丢失的问题。1.8后把链表的头插法改成了尾插法解决了死循环</p>
<p>数据丢失在 JDK1.7 和 JDK 1.8 中都存在</p>
<p>JDK 1.8 后，在 HashMap 中，多个键值对可能会被分配到同一个桶（bucket），并以链表或红黑树的形式存储。多个线程对 HashMap 的 put 操作会导致线程不安全，具体来说会有数据覆盖的风险。</p>
<p>并发环境下，推荐使用 <code>ConcurrentHashMap</code></p>
</li>
<li><p>JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有什么不同？</p>
<ul>
<li><p><strong>线程安全实现方式</strong>：JDK 1.7 采用 <code>Segment</code> 分段锁来保证安全， <code>Segment</code> 是继承自 <code>ReentrantLock</code>。JDK1.8 放弃了 <code>Segment</code> 分段锁的设计，采用 <code>Node + CAS + synchronized</code> 保证线程安全，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点。</p>
<blockquote>
<p>CAS compareAndSwap，如果目标地址的值与旧的预期值相同，就改成新的目标值。</p>
<p>相对于Synchronized对整个方法上锁，CAS是针对变量的原子操作，性能更好，但也有缺点：</p>
<ol>
<li><p>CAS的实现是通过循环判断预期值实现，如果长时间CAS不成功会占用CPU大开销</p>
</li>
<li><p>ABA问题，即存在这种情况：</p>
<p>在读取值A后，根据A计算值B，最后CAS把A改成B的过程中，存在其他线程把A改成其他再改回A。</p>
<p>如果ABA问题会影响程序的正确性，还是使用sychronized</p>
</li>
</ol>
</blockquote>
</li>
<li><p><strong>Hash 碰撞解决方法</strong> : JDK 1.7 采用拉链法，JDK1.8 采用拉链法结合红黑树（链表长度超过一定阈值时，将链表转换为红黑树）。</p>
</li>
<li><p><strong>并发度</strong>：JDK 1.7 最大并发度是 Segment 的个数，默认是 16。JDK 1.8 最大并发度是 Node 数组的大小，并发度更大</p>
</li>
</ul>
</li>
<li><p>concurrentHashMap 为什么 key 和 value 不能为 null？</p>
</li>
</ul>
<p>  因为null会使结果存在二义性，究竟是kv本身为null，还是kv不存在？map的get方法是不加锁的，意味着当使用get时同时会有其他线程修改同一个node，这样在并发场景下无法做出正确的判断，是错误的。而在单线程下的hashMap允许这么做，不会因为二义性而出错</p>
</li>
<li><p>泛型</p>
<ul>
<li><p>就是广泛、任意、通用的类型。</p>
</li>
<li><p>有泛型程序、泛型类、泛型方法，是说这个类、方法、程序是针对T设计的，而不只是指输入参数是T</p>
</li>
<li><p>使用泛型机制编写的程序代码，要比那些杂乱地使用 Object 变量，然后再进行强制类型转换的代码具有更好的安全性和可读性</p>
</li>
<li><p>泛型通过类型参数&lt; T &gt; 实现，对类型参数的限定：&lt; T extends x &amp;&amp; x&gt;</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/346486993">Java泛型中的类型擦除详解 - 知乎 (zhihu.com)</a>尽管是伪泛型，编译器已经先将类型进行了转换，而不需要我们手动强制转换</p>
</li>
<li><p>🫡类型擦除会导致的问题部分待理解…</p>
</li>
</ul>
</li>
<li><p>接口</p>
<ul>
<li><p>在 Java 程序设计语言中，接口不是类，而是对类的一组需求描述，这些类要遵从接口描 述的统一格式进行定义</p>
</li>
<li><p>接口中的方法都自动地被设置为 public，接口中的域将被自动设为 public static final。</p>
<p>Java 语言规范却建议不要书写这些多余的关键字：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//规范接口示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Powered</span> <span class="keyword">extends</span> <span class="title class_">Moveable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> milesPerCallonO;</span><br><span class="line">    <span class="type">double</span> <span class="variable">SPEED_LIHIT</span> <span class="operator">=</span> <span class="number">95</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>每个类只能扩展于一个类，但能实现多个接口，这是抽象类和接口的区别，也是引入接口概念的原因</p>
</li>
</ul>
</li>
<li><p>集合(List)&lt;–&gt;数组(Array)</p>
<ul>
<li><p>数组转集合要容易，只需使用Arrays.asList 包装器可以达到这个目的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] values = ...;</span><br><span class="line">HashSet&lt;String&gt; staff = <span class="keyword">new</span> <span class="title class_">HashSeto</span>(Arrays.asList(values));</span><br></pre></td></tr></table></figure>
</li>
<li><p>集合转数组，使用的是collection.toArray，返回是对象数组，不能强制转换，想转换使用以下方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] values = (String[]) staff.toArray()；<span class="comment">// Error!</span></span><br><span class="line">String[] values = staff.toArray(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="number">0</span>)); <span class="comment">//right</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>视图和包装器</p>
<ul>
<li><p>初看起来， 好像这个方法创建了一个新集， 并将映射中的所有键都填进去，然后返回这个集。实际上，asList方法返回一个实现 List接口的类对象， 这个类的方法对原数组tests进行操作。这种集合称为<strong>视图</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Test[] tests = <span class="keyword">new</span> <span class="title class_">Test</span>[<span class="number">10</span>];</span><br><span class="line">List&lt;Test&gt; testList = Arrays.asList(tests);</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过查看源码，实际上asList new了一个ArrayList&lt;&gt;(test)，而这个构造方法只是把List里的数组a[]指向test，即没有创建新数组，降低存储代价，但使用权限也受限了</p>
</li>
</ul>
</li>
</ul>
<p><strong>StringBuffer和StringBuilder的区别，和String的区别</strong></p>
<p>StringBuffer所有方法都是Synchronized修饰，而StringBuilder没有，</p>
<p>所以StringBuffer是线程安全的，适用于多线程，StringBuilder是不安全的，适用于单线程，前者性能差，后者性能更好</p>
<p>这两者都是用于处理可变字符串，String是不可变字符串，每次操作字符串都会创建新的字符串对象</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><ul>
<li><p>父类&amp;子类-extends</p>
<ul>
<li><p>多态</p>
<ul>
<li><p>多态是指用相同的<strong>接口</strong>去表示不同的<strong>实现</strong>。</p>
</li>
<li><p>好处：<strong>不管实现部分代码怎么改动都不会影响到使用部分的代码</strong></p>
</li>
<li><p>程序中出现超类(即父类)对象的任何地方都可以用子类对象置换。</p>
</li>
</ul>
</li>
<li><p>JAVA中，对象变量是多态的，一个a类变量可以引用a类对象，也可以引用a类的任意子类对象</p>
</li>
<li><p>在运行时能够自动地选择调用哪个方法的现象称为动态绑定</p>
</li>
<li><p><strong>尽量运用多态！</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里应考虑用多态，如果action表示相同概念，那就定义一个action在超类或接口中，然后直接调用action()即可</span></span><br><span class="line"><span class="keyword">if</span> (x is of type1)</span><br><span class="line">	action1(x);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x is of type2)</span><br><span class="line">	action2(x);</span><br></pre></td></tr></table></figure>
</li>
<li><p>覆盖方法-super</p>
<ul>
<li><p>在写覆盖方法时，如果想要<strong>使用父类的方法</strong>，使用**super.xx()**，因为如果没有super，当前覆盖方法与父类方法同名，调用的是xx()，就会无限次调用自己方法导致崩溃</p>
</li>
<li><p>super和this引用不同，super不是一个对象的引用，不能将super赋值给另一个对象变量，它只是一个指示编译器调用父类方法的<strong>关键字</strong></p>
</li>
<li><p>使用 super 调用构造器的语句必须是子类构造器的<strong>第一条语句</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Findareas</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String []agrs)</span>&#123;</span><br><span class="line">        Figure f= <span class="keyword">new</span> <span class="title class_">Figure</span>(<span class="number">10</span> , <span class="number">10</span>);</span><br><span class="line">        Rectangle r= <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="number">9</span> , <span class="number">5</span>);</span><br><span class="line">        Figure figref;</span><br><span class="line">        figref=f;</span><br><span class="line">        System.out.println(<span class="string">&quot;Area is :&quot;</span>+figref.area());</span><br><span class="line">        figref=r;</span><br><span class="line">        System.out.println(<span class="string">&quot;Area is :&quot;</span>+figref.area());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Figure</span>&#123;</span><br><span class="line">    <span class="type">double</span> dim1;</span><br><span class="line">    <span class="type">double</span> dim2;</span><br><span class="line">    Figure(<span class="type">double</span> a , <span class="type">double</span> b) &#123;</span><br><span class="line">        dim1=a;</span><br><span class="line">        dim2=b;</span><br><span class="line">    &#125;</span><br><span class="line">    Double <span class="title function_">area</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Inside area for figure.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>(dim1*dim2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_">Figure</span> &#123;</span><br><span class="line">    Rectangle(<span class="type">double</span> a, <span class="type">double</span> b) &#123;</span><br><span class="line">        <span class="built_in">super</span>(a ,b);</span><br><span class="line">    &#125;</span><br><span class="line">    Double <span class="title function_">area</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Inside area for rectangle.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>(dim1*dim2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>阻止继承-final</p>
<p>有时候，可能希望阻止人们利用某个类定义子类。<strong>不允许扩展</strong>的类被称为 final 类。类中的特定<strong>方法</strong>也可以被声明为 final。如果这样做，子类就不能覆盖这个方法（<strong>final 类中的所有方法自动地成为 final 方法</strong>）</p>
</li>
<li><p>动态绑定</p>
<ul>
<li>如果是 private 方法、 static 方法、 final 方法或者构造器， 那么编译器将可以准确地知道应该调用哪个方法， 我们将这种调用方式称为静态绑定</li>
</ul>
</li>
</ul>
</li>
<li><p>与之对应，不确定是父类还是当前类的方法，需要运行时绑定某个最合适的方法，成为动态绑定</p>
<ul>
<li><p>重载</p>
<ul>
<li><p>一个类有多个方法有相同名字、不同参数，就会产生重载</p>
</li>
<li><p>编译器挑选具体执行哪个方法，这个过程时重载解析</p>
</li>
<li><p>参数不同包括：</p>
<ul>
<li><p>个数不同</p>
</li>
<li><p>类型不同</p>
</li>
<li><p>类型<strong>排列顺序</strong>不同</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>强制类型转换</p>
<ul>
<li><p>子类变量能直接引用父类对象，但当父类想要引用子类对象时需要强制类型转换</p>
</li>
<li><p>类型转换只能在继承层次内进行</p>
</li>
<li><p>转换前先使用instanceof判断左边的类是否是右边的实例，当左边是右边类或子类所创建对象时，返回true；否则，返回false</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a <span class="keyword">instanceof</span> Manager)&#123;</span><br><span class="line">	<span class="type">Manager</span> <span class="variable">boss</span> <span class="operator">=</span> (Manager) a;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>应尽量少用</p>
</li>
</ul>
</li>
<li><p>抽象类</p>
<ul>
<li><p>只要类中有方法是抽象方法，那么该类就是抽象类，就必须有abstract声明</p>
</li>
<li><p>抽象类中可以有具体数据和具体方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name ;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">getDescription</span><span class="params">()</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> String getName0</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>继承抽象类可以不完全实现全部抽象方法，部分实现则子类仍然是抽象类，这点和接口还是蛮不同</p>
</li>
<li><p>抽象类不能被实例化，但可以定义抽象类变量，但只能引用非抽象子类对象</p>
</li>
</ul>
</li>
<li><p>protected</p>
<ul>
<li>private、public、protected</li>
<li>最好将类中域标记为private，方法标记为public</li>
<li>要想只让子类可见，用protected</li>
<li>但是！不要使用protected，<strong>这是个猪头设计</strong>！因为任何一个类都能继承你，那么就可以使用你的protected类，形同虚设，并且在同一个包里的所有类也可以使用proteced类，不管是不是子类</li>
</ul>
</li>
</ul>
</li>
<li><p>Object</p>
<ul>
<li><p>Object是Java所有类的始祖，因此熟悉它很重要</p>
</li>
<li><p>可以使用 Object 类型的变量引用任何类型的对象</p>
</li>
<li><p>equals</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/changshuchao/article/details/86714875">(61条消息) Java中的equals()方法_changshuchao的博客-CSDN博客</a></li>
<li>通过重写equals方法，可以自定义相等概念</li>
<li>&#x3D;&#x3D;是比较两个类的内存地址是否相同，equals在object类中的实现就是=&#x3D;，但在其他的包装类如string就拓展到值相等等，这样的功能也是instanceof无法做到的。</li>
</ul>
</li>
<li><p>hashCode</p>
<ul>
<li>每个对象都有一个默认散列码，值为对象的存储地址</li>
</ul>
</li>
<li><p>toString</p>
<ul>
<li><p>返回对象值的字符串，是个非常有用的调试工具</p>
</li>
<li><p>Object中的toString方法是返回对象所属的类名和散列码</p>
</li>
<li><p>绝大多数（但不是全部）的 toString方法都遵循这样的格式：类的名字，随后是一对方括号括起来的域值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> getClass().getName()</span><br><span class="line">		+ <span class="string">&quot;[name=&quot;</span> + name]<span class="string">&quot;;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用System.out.println(x)，其实就是调用x.toString()</p>
</li>
<li><p>数组继承了object的toString，要想吧数组转成字符串，使用Array.toString</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] luckyNumbers = &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, ll, <span class="number">13</span> &#125; ;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span> + luckyNumbers;</span><br><span class="line"><span class="comment">//s结果为“ [I@la46e30”（前缀 [I 表明是一个整型数组）</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> Arrays.toString(luckyNumbers);</span><br><span class="line"><span class="comment">//s结果为“ [2,3,5,7，11，13]”</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>发现平时不经思考直接用的调试方法，其实就是toString方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;Current position = &quot;</span> + position);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>泛型数组列表</p>
<ul>
<li>ArrayList中与数组a.length等价的是ArrayList.size()</li>
<li>一旦能够确认数组列表的大小不再发生变化，就可以调用 trimToSize方法。这个方法将 存储区域的大小调整为当前元素数量所需要的存储空间数目。垃圾回收器将回收多余的存储 空间。</li>
<li>ArrayList 类并不是 Java 程序设计语言的一部分；它只是一个由某些人编 写且被放在标准库中的一个实用类。</li>
<li>在创建是最好是声明清楚泛型类</li>
</ul>
</li>
<li><p>包装器</p>
<ul>
<li><p>有时候需要把基本类型转换成对象。所有的基本类型都有对应的类，这些类就是包装器。</p>
</li>
<li><p>Integer、Long、Float、Double、Short、Byte、Character 、Void 和 Boolean (前 6 个类派生于公共的超类 Number)。</p>
</li>
<li><p>对象包装器类是<strong>不可变</strong>的，即一旦构造了包装器，就<strong>不允许更改包装在其中的值</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">n = <span class="number">2</span>; <span class="comment">//won&#x27;t work!</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对象包装器类还是 final , 因此不能定义它们的子类</p>
</li>
<li><p>尖括号中的类型参数不允许是基本类型，如ArrayList&lt;Integer&gt;，里头是类。</p>
</li>
<li><p>当然ArrayList&lt;Integer&gt;操作的效率是低于int[]的</p>
</li>
<li><p>自动装箱</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由编译器自动完成</span></span><br><span class="line"><span class="comment">//自动装箱</span></span><br><span class="line">list.add(<span class="number">3</span>)</span><br><span class="line">=&gt;</span><br><span class="line">list.add(Integer.valueof(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//自动拆箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> list.get(i)</span><br><span class="line">=&gt;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> list.get(i).intValue()</span><br><span class="line">    </span><br><span class="line"><span class="comment">//甚至在算术表达式中也能够自动地装箱和拆箱</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">n++;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于**&#x3D;&#x3D;操作符**来说，如果比较的数据是基本类型，则比较它们的值，如果比较的是对象，则会比较对象的内存地址。另外，如果一个是基本类型、一个是包装类型，在比较前会先把包装类型拆箱成基本类型，然后进行比较。</p>
</li>
<li><p>包装类和基本类型很多时候一样，但相等性不同，基本类型能直接用=&#x3D;，而对于包装器对象，<strong>应使用equals</strong>比较</p>
</li>
<li><p>方法参数数量可变</p>
<p>这样就不限定参数数量，在编译时编译器自动编译，就很方便</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法就是&quot;...&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintStream</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> PrintStream <span class="title function_">printf</span><span class="params">(String fmt , Object... args)</span> &#123; 		<span class="keyword">return</span> format(fmt, args); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">System.out.printf(<span class="string">&quot;%d %s&quot;</span>, n, <span class="string">&quot;widgets&quot;</span>);<span class="comment">//就是因为有这个功能，所以用的时候能无限加逗号咯</span></span><br><span class="line">                  </span><br><span class="line"><span class="comment">//编译器将 new Object[ ] &#123;n, &quot;widgets&quot;&#125; 传递给 printf 方法。</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>在 Java 语言中， 给出了 3 种处理系统错误的机制：</p>
<ul>
<li>异常</li>
<li>日志</li>
<li>断言</li>
</ul>
</li>
</ul>
<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><ul>
<li><p>Java中所有的异常对象都派生于Throwable 类</p>
</li>
<li><p>异常分为两种，RuntimeException和其他异常</p>
</li>
<li><p>“ 如果出现 RuntimeException 异常， 那么就一定是你的问题”</p>
</li>
<li><p>Java 语 言 规 范 将 派 生 于 Error 类 或 RuntimeException 类的所有异常称为非受查 ( unchecked ) 异常，所有其他的异常称为受查（ checked) 异常</p>
</li>
<li><p>两种方法处理异常</p>
<ul>
<li><strong>传递异常</strong>， 就必须在方法的首部添加一个 throws 说明符， 以便告知调用者这 个方法可能会抛出异常。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Image <span class="title function_">loadlmage</span><span class="params">(String s)</span> <span class="keyword">throws</span> FileNotFoundException, EOFException</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>捕获异常</strong>， 必须设置 try&#x2F;catch语句块</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">(String filename)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Filei</span>叩utStream(filename);</span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line">        <span class="keyword">while</span> ((b = in.read()<span class="number">3</span> != -<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">       		process input</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//可以捕获多个异常</span></span><br><span class="line">    <span class="keyword">catch</span> (IOException exception)</span><br><span class="line">    &#123;</span><br><span class="line">    	exception.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//一个catch捕获多种异常</span></span><br><span class="line">    <span class="keyword">catch</span> (FileNotFoundException | UnknownHostException e)</span><br><span class="line">    &#123;</span><br><span class="line">    	emergency action <span class="keyword">for</span> missing files and unknown hosts</span><br><span class="line">        <span class="comment">//在catch中也可以抛出异常，直接扔就行</span></span><br><span class="line">        logger.log(level, message, e); <span class="comment">//写个日志记录也不错</span></span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">		<span class="comment">//用于资源回收等善后工作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>强烈建议解搞合 try&#x2F;catch 和 try&#x2F;finally 语句块。这样可以提高代码的清晰度</p>
</li>
<li><p>断言</p>
<ul>
<li><p>方法就是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果结果为 false, 则抛出一个 AssertionError 异常</span></span><br><span class="line"><span class="comment">//这里程序中想断言x是一个非负数值</span></span><br><span class="line"><span class="keyword">assert</span> x &gt;= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>assert语句仅仅在debug版本中才有效，而在release版本中无效；</p>
</li>
<li><p>断言只应该用于在测试阶段确定程序内部的错误位置。</p>
</li>
<li><p>很少使用</p>
</li>
</ul>
</li>
<li><p>日志</p>
<ul>
<li><p>日志的作用就是在测试、生产环境没有 Debug 调试工具时开发、测试人员定位问题的手段，会比简单的printf强大太多太多!🤩</p>
</li>
<li><p>优秀的项目都是能根据日志定位问题的，而不是在线调试，或者半天找不到有用的日志而抓狂</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/62110673">Java 程序如何正确的打日志 - 知乎 (zhihu.com)</a></p>
</li>
</ul>
</li>
<li><p>调试技巧</p>
<ul>
<li><p>一个不太为人所知但却非常有效的技巧是在每一个类中放置一个单独的 main方法。这样就可以对每一个类进行单元测试。利用这种技巧， 只需要创建少量的对象， 调用所有的方法， 并检测每个方法是否能够 正确地运行就可以了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">	methods andfields</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">    	test code</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试工具Junit</p>
</li>
</ul>
</li>
</ul>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><ul>
<li><p>接口-implements</p>
<ul>
<li><p>接口不是类，而是对类的一组需求描述</p>
</li>
<li><p>接口中的所有方法自动地属于 public，因此，在接口中声明方法时，不必提供关键字public </p>
</li>
<li><p>接口中的域将被自动设为 public static final</p>
</li>
<li><p>不同于抽象类，接口中不能有方法</p>
</li>
<li><p>每个类只能够拥有一个超类， 但却可以实现多个接口</p>
</li>
<li><p>有些程序设计语言允许一个类有多个超类， 例如 C++。我们将此特性称为多重继承 ( multiple inheritance。) 而 Java 的设计者选择了不支持多继承，其主要原因是多继承会让语言 本身变得非常复杂（如同 C++，) 效率也会降低（如同 Eiffel。</p>
</li>
<li><p>对象克隆</p>
<ul>
<li><p>这么做实际上并没有拷贝</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Employee</span> <span class="variable">original</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;John Public&quot;</span>, <span class="number">50000</span>);</span><br><span class="line"><span class="type">Employee</span> <span class="variable">copy</span> <span class="operator">=</span> original;</span><br><span class="line">copy.raiseSalary(lO); <span class="comment">// oops-also changed original</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>要想真正创建一个新的副本，需要克隆。clone 方法是 Object 的一个 protected 方法，这说明你的代码不能 直接调用这个方法。只有 Employee 类可以克隆 Employee 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Employee</span> <span class="variable">copy</span> <span class="operator">=</span> original,clone();</span><br><span class="line">copy.raiseSalary(lO); <span class="comment">// OK original unchanged</span></span><br></pre></td></tr></table></figure>

<p>但这只是<strong>浅克隆</strong>，即没有克隆对象中引用的其他对象，原对象和克隆的对 象仍然会共享一些信息</p>
</li>
<li><p><strong>Cloneable 接口的出现与接口的正常使用并没有关系</strong>。也就是说，这个接口并没有指定 clone 方法，clone方法是你的类从Object 类继承的，而这个接口只是作为一个标记(吐槽…)。</p>
</li>
<li><p>如果在一个对象上调用 clone, 但这个对象的类并没有实现 Cloneable 接口， Object 类 的 clone 方法就会拋出CloneNotSupportedException</p>
</li>
<li><p>深拷贝例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> Employee <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">cloned</span> <span class="operator">=</span> (Employee) <span class="built_in">super</span>.clone();</span><br><span class="line">        cloned.hireDay = (Date) hireDay. clone();</span><br><span class="line">        <span class="keyword">return</span> cloned;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>lamda表达式</p>
<ul>
<li>lambda表达式出现是为了简洁定义代码块，而不需要重新建个类去装方法，直接就可以传递代码块。</li>
<li>相当于一个匿名方法…大致了解啥意思，用时再说</li>
</ul>
</li>
<li><p>内部类</p>
<ul>
<li>就是一个类里面放了一个类</li>
<li>内部类可以直接使用创建它的外围类对象的数据域，包括private数据域，而不需要使用get set方法</li>
<li>只有内部类可以是私有类，当内部类声明为私有，那就只有当前类可以使用和构造。常规类只可以具有包可见性，或公有可见性</li>
</ul>
</li>
</ul>
<h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><ul>
<li>在创建对象后会加载类(子类加载完后加载父类)，加载完后堆中会产生一个class类的对象，这个class包含了类的结构信息，这个class对象就像个镜子，可以通过这个镜子看到自己或其他人</li>
<li>java时准动态语言。动态语言就是运行时数据结构可以发生改变的语言，静态语言不行，反射使java变成准动态语言。</li>
<li>似乎明白了，通过反射机制创建对象，区别于传统方法，在于，<code>Class.forName(&quot;Person&quot;)</code>并不是直接获取到<code>Person</code>对象。相反，它是通过<code>Class.forName()</code>方法动态地加载并返回<code>Person</code>类的<code>Class</code>对象。再根据这个class对象构造person对象，相当于根据镜像人构造真人！</li>
<li>相当于class对象都准备好了，用的时候再构造，而不用一遍遍反复编译构造编死在代码里，更灵活，解耦合</li>
</ul>
<h4 id="并发基础🐾"><a href="#并发基础🐾" class="headerlink" title="并发基础🐾"></a>并发基础🐾</h4><blockquote>
<p>🔎<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/342060129">图解Java线程的6种状态及切换 - 知乎 (zhihu.com)</a></p>
</blockquote>
<ul>
<li><p>进程资源</p>
<p>堆、方法区、PC、虚拟机栈、本地方法区</p>
</li>
<li><p>线程资源</p>
<p>多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong></p>
</li>
<li><p>线程的6个状态，定义在thread类中的state枚举里</p>
<img src="/2023/10/06/%E6%88%91%E7%82%BC%E9%BB%84%E9%87%91%E4%B8%B9%E4%B9%8BJAVA%E8%AF%9E%E7%94%9F/v2-1319f27379e4745d02b40ea12b9307cb_r.jpg" class="" title="v2-1319f27379e4745d02b40ea12b9307cb_r">
</li>
<li><p>守护线程：为其它线程提供服务</p>
</li>
<li><p>创建新线程的方法有四种</p>
<ul>
<li><p>继承thread类实现覆盖方法</p>
<blockquote>
<p>Thread 类本质上是实现了 Runnable 接口的一个实例，代表一个线程的实例。启动线程的唯一方法就是通过Thread 类的start()实例方法。start()方法是一个 native 方法，它将启动一个新线程，并执行run()方法。</p>
</blockquote>
</li>
<li><p>线程任务和线程管理解耦合</p>
<ul>
<li><p>实现<strong>Runnable</strong>，传给thread类对象，thread.run将调用runnable.run</p>
</li>
<li><p>实现<strong>Callable</strong>，通过<strong>future task包装器</strong>，传给thread类对象。</p>
<p>Callable 与 Runnable 类似，但是有返回值。Future 保存异步计算的结果。</p>
<blockquote>
<p>FutureTask 包装器是一种非常便利的机制， 可将 Callable转换成 Future 和 Runnable, 它同时实现二者的接口。才发现原来接口是可以多继承的！类只能单一继承，实现多个接口</p>
<p>Q：为什么Java不支持多继承？</p>
<p>Q：为什么 String 在 Java 中是 final ？</p>
<p>源码：public interface RunnableFuture<V> extends Runnable, Future<V></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Callable&lt;Integer&gt; nyComputation = . . .;</span><br><span class="line">FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;Integer&gt;(myConiputation);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task); <span class="comment">// it&#x27;s a Runnable</span></span><br><span class="line">t.startO；</span><br><span class="line"><span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> task.get()；<span class="comment">// it&#x27;s a Future，主线程阻塞直到任务返回结果</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">get本质是调用thread.yield，线程进入就绪状态，放弃使用cpu</span></span><br><span class="line"><span class="comment">Thread.yield()，一定是当前线程调用此方法，当前线程放弃获取的CPU时间片，但不释放锁资源，由运行状态变为就绪状态，让OS再次选择线程。作用：让相同优先级的线程轮流执行，但并不保证一定会轮流执行。实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。Thread.yield()不会导致阻塞。该方法与sleep()类似，只是不能由用户指定暂停多长时间。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>ExecutorService执行器，使用线程池对线程资源缓存，避免频繁创建销毁线程，并减少响应时间同时限制并发线程数防止崩溃</p>
</li>
</ul>
</li>
<li><p>主线程等待子线程</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/aliveneko/p/10998058.html#locksupport">Java多线程之以7种方式让主线程等待子线程结束 - AliveNeko - 博客园 (cnblogs.com)</a></p>
</li>
<li><p>thread.sleep()和object.wait()区别</p>
<blockquote>
<ol>
<li><code>wait()</code> 是对象级别的方法，而 <code>sleep()</code> 是线程级别的方法。</li>
<li><code>wait()</code> 用于线程之间的协调和通信，而 <code>sleep()</code> 用于让当前线程休眠一段时间。</li>
<li><code>wait()</code> 会释放对象的锁，而 <code>sleep()</code> 不会释放锁。</li>
<li><code>wait()</code> 必须在同步块中使用（通常在<code>synchronized</code>方法或代码块中），而 <code>sleep()</code> 可以在任何地方使用。</li>
</ol>
</blockquote>
</li>
<li><p>为什么wait要定义在Object中，而不定义在Thread中？  为什么wait必须写在同步代码块中？</p>
<blockquote>
<p>锁只是个标记，存在对象头里面。这个问题我个人理解可以从两个角度解释</p>
<p>一个是从面向对象的角度，可以把wait和notify直接理解为get和set方法。wait和notify方法都是对对象的锁进行操作，那么自然这些方法应该属于对象。举例来说，门对象上有锁属性，开锁和关锁的方法应该属于门对象，而不应该属于人对象。</p>
<p>一个是从观察者模式的角度，对象是被观察者，线程是观察者。被观察者的状态如果发生变化，理应有被观察者去轮询通知观察者，否则的话，观察者怎么知道notify方法应该在哪个时刻调用？n个观察者的notify又如何做到同时调用？</p>
</blockquote>
</li>
<li><p>线程安全</p>
<ul>
<li>线程安全是指在多线程环境下，一个共享的数据结构或代码段能够正确地被多个线程同时访问，而不会导致数据损坏或不一致的问题。线程安全的设计旨在防止竞态条件和数据竞争等多线程并发问题。</li>
<li>主要的线程安全问题包括以下几种：<ol>
<li><strong>竞态条件（Race Condition）</strong>：当两个或多个线程同时访问共享资源，并且至少一个线程试图修改该资源时，可能会导致竞态条件。这种情况下，执行的结果可能会依赖于线程的调度顺序，从而导致不确定的行为。</li>
<li><strong>数据竞争（Data Race）</strong>：数据竞争发生在多个线程同时访问相同的内存位置，并且至少有一个线程进行写操作。如果没有适当的同步机制，数据竞争可能导致内存访问错误和不一致的数据状态。</li>
<li><strong>死锁（Deadlock）</strong>：死锁是指两个或多个线程相互等待对方释放资源，导致它们都无法继续执行的情况。死锁是多线程编程中的常见问题，需要小心设计和管理锁。</li>
</ol>
</li>
<li>为实现线程安全，通常采取以下策略：<ul>
<li><strong>互斥锁（Mutex）</strong>：使用锁机制来保护共享资源，确保同一时刻只有一个线程可以访问该资源，其他线程必须等待。Java中的 <code>synchronized</code> 和 <code>ReentrantLock</code> 就是常见的互斥锁实现。</li>
<li><strong>原子操作（Atomic Operation）</strong>：通过使用原子操作可以确保某个操作在多线程环境下是不可分割的，从而避免了竞态条件。Java中的 <code>java.util.concurrent.atomic</code> 包提供了原子数据类型。</li>
<li><strong>线程安全的数据结构</strong>：使用线程安全的数据结构，如 <code>ConcurrentHashMap</code> 或 <code>CopyOnWriteArrayList</code>，这些数据结构内部实现了同步机制。</li>
<li><strong>不可变对象（Immutable Objects）</strong>：设计不可变对象，它们的状态在创建后不能被修改，因此可以在多线程环境下安全共享。</li>
<li><strong>并发编程模式</strong>：使用并发编程模式，如生产者-消费者模式或读写锁模式，来解决特定的并发问题。</li>
</ul>
</li>
</ul>
</li>
<li><p>同步 </p>
<ul>
<li><p>又名：java.util.concurrent 并发包使用指南</p>
</li>
<li><p>总结：在代码中应该使用哪一种解决多线程对共享资源的竞态？ Lock 和 Condition 对象还是同步方法？</p>
<ul>
<li>最好既不使用 Lock&#x2F;Condition 也不使用 synchronized 关键字。在许多情况下你可以使用 java.util.concurrent 包中的成熟机制，如阻塞队列等远离底层机制已经包装好的方法，它会为你处理所有的加锁。</li>
<li>如果 synchronized 关键字适合你的程序， 那么请尽量使用它，这样可以减少编写的代码数量，减少出错的几率。</li>
<li>如果特别需要 Lock&#x2F;Condition 结构提供的独有特性时，才使用 Lock&#x2F;Condition。</li>
</ul>
</li>
<li><p>并发包的底层其实就是锁+条件</p>
</li>
<li><p>底层两种基础机制：synchronized关键字和reentrantLock类锁</p>
</li>
<li><p>锁对象</p>
<ul>
<li>“reentrant lock”（<strong>可重入锁</strong>）是指当一个线程在持有锁的时候，它可以再次尝试获取该锁，而不会因为自己已经持有锁而被阻塞。这种机制允许线程在递归调用或者嵌套执行时，能够安全地重复地获取相同的锁，而不会造成死锁或其他并发问题。确保在<strong>同一时间只有一个线程</strong>能够访问被锁保护的代码块。</li>
<li>Java中的ReentrantLock类就是一个可重入锁的实现，它提供了与synchronized关键字类似的功能，但更加灵活和强大。</li>
<li><strong>公平性</strong>是公平锁的关键特性。当多个线程争夺锁时，公平锁会按照请求锁的顺序来分配锁，即先来先得，严格按照请求锁的顺序排队。这确保了所有线程都有公平的机会获得锁，避免了线程饥饿（某些线程一直无法获得锁）。</li>
<li>公平锁的实现可能会引入额外的性能开销，因为要维护一个队列来管理等待线程的顺序，而且在高竞争情况下可能导致一些性能问题。</li>
<li>非公平锁并不考虑线程的请求顺序，它允许一个新的线程在还有其他线程等待锁的情况下直接获取锁。这意味着在一定情况下，后来的线程有可能在先前等待的线程之前获取锁，从而可能引入不公平性。</li>
<li>在大多数情况下，非公平锁在性能上表现更好，因此是默认的选择。</li>
<li><strong>默认</strong>reentrantLock是<strong>非公平锁</strong></li>
</ul>
</li>
<li><p>条件对象</p>
<ul>
<li>await、signalAll、signal(随机解除等待集中的某线程的阻塞状态这比解除所有线程的 阻塞更加有效，但也存在危险。如果随机选择的线程发现自己仍然不能运行， 那么它再次被 阻塞。如果没有其他线程再次调用 signal, 那么系统就死锁了)</li>
<li>锁和条件配合使用</li>
</ul>
</li>
<li><p>synchronized关键字</p>
<ul>
<li><p>一般情况下，不需要手动去用条件和锁去控制，java中有封装好的机制能做到锁控制同步。从 1.0 版开始，Java 中的<strong>每一个对象都有一个内部锁</strong>。如果一个方法用 synchronized关键字声明，那么<strong>对象的锁将保护整个方法</strong>。也就是说，要调用该方法，线程必须获得内部的对象锁。</p>
<p>wait和notify是object类的final方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	method body...</span><br><span class="line">    wait(); </span><br><span class="line">	notifyAll();	</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">等价于=&gt;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">this</span>.intrinsidock.lock();</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">    	method body..</span><br><span class="line">        await();</span><br><span class="line">        signalAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123; <span class="built_in">this</span>.intrinsicLock.unlock(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>volatile关键字</p>
<ul>
<li>Volatile意思是“易变的”，应该解释为“直接存取原始内存地址”比较合适。</li>
<li>有两个作用：保证变量的内存可见性(多线程共享)、禁止指令重排序</li>
<li><strong>如果一个字段被声明成volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的，同时还会禁止指令重排序</strong></li>
<li>volatile 提醒编译器它后面所定义的变量随时都有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，都会<strong>直接从变量地址中读取数据</strong>。</li>
<li>如果没有 volatile 关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象。</li>
<li>所以<strong>遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问</strong>。</li>
</ul>
</li>
<li><p>核心卷更推荐的同步机制</p>
<ul>
<li><p>这些都是并发包下封装好的结构，相对于拿野生锁来手动保护，核心卷更推荐这些</p>
</li>
<li><p>阻塞队列-BlockingQueue</p>
<ul>
<li><p>为什么叫阻塞队列？</p>
<ul>
<li>当要添加元素但队列满，当要读取而队列空，阻塞队列会导致线程阻塞</li>
</ul>
</li>
<li><p>使用队列，可以安全地从一个线程向另 一个线程传递数据。只有该线程可以访问对象的内部，因此不需要同步。</p>
</li>
</ul>
</li>
<li><p>线程安全的集合们</p>
<ul>
<li>java.util.concurrent 包提供了映射、 有序集和队列的高效实现：ConcurrentHashMap、ConcurrentSkipListMap、ConcurrentSkipListSet、ConcurrentLinkedQueue</li>
<li>这些集合使用复杂的算法，通过允许并发地访问数据结构的不同部分来使竞争极小化</li>
<li>从 Java 的初始版本开始，Vector 和 Hashtable 类就提供了线程安全的动态数组和散列表的 实现。现在这些类被弃用了， 取而代之的是 AnayList 和 HashMap 类。这些类不是线程安全 的，而集合库中提供了不同的机制。任何集合类都可以通过使用同步包装器（synchronization wrapper) 变成线程安全的</li>
</ul>
</li>
</ul>
</li>
<li><p>执行器</p>
<ul>
<li><p>因为创建线程涉及和操作系统交互，大量创建短期线程会降低性能</p>
</li>
<li><p>当遇到要创建大量线程的情况，应使用执行器类Excutor中的<strong>线程池</strong>解决</p>
<ul>
<li>一个线程池中包含许多<strong>准备运行的 空闲线程</strong>。将 <strong>Runnable</strong> 对象交给线程池， 就会有一个线程调用 run 方法。 当 run 方法退出 时，线程不会死亡，而是在池中准备为下一个请求提供服务。</li>
<li>另一个使用线程池的理由是减少并发线程的数目。如果有一个会创建许多线程的算法， 应该使用一个线程数“ 固定的” 线程池以 <strong>限制并发线程的总数</strong></li>
</ul>
</li>
<li><p>执行器Executor类中有如下静态工厂方法构建线程池：</p>
<ul>
<li>newCachedThreadPool-空闲线程会保留60秒，没有可用线程就创建</li>
<li>newFixedThreadPool-线程数固定，不够用了排队等候</li>
<li>newSingleThreadExecutor-只有一个线程，onlineWait辣！</li>
<li>newScheduledThreadPool、newSingleThreadScheduledExecutor-预定执行</li>
</ul>
</li>
<li><p>创建后点击submit提交runnable对象即可，叮咚！</p>
</li>
</ul>
</li>
<li><p>同步器</p>
<ul>
<li>concurrent包中还提供好这些机制，对应于一些场景，如果有一个相互合作的线程集满足这些行为模式之一， 那么应该<strong>直接重用合适的库类</strong>而<strong>不要试图提供手工的锁与条件</strong>的集合。</li>
<li>Semaphore、CountDownLatch、CyclicBarrier、Exchanger、SynchronousQueue</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>reetrantLock和synchronized区别</strong></p>
<p>从实现来说reetrantlock是lock接口的实现类，需要手动控制锁和管理锁，synchronized是关键字，是由JVM自动实现对代码块的锁定和释放</p>
<p>从使用来说，reentrantlock更加灵活，也意味着可以实现更高级别的控制，比如是按可中断锁，也就是当持有锁线程长期不释放，等待线程可以选择放弃等待，或者公平锁，可以通过参数把默认非公平锁改成公平锁，而syn默认是非公平锁，虽然公平锁性能不好。</p>
<p>synchronized就是写死的，适用于简单同步需求</p>
<p><strong>悲观锁和乐观锁</strong></p>
<p>是两种并发处理机制</p>
<p>悲观锁认为每次访问共享资源是都会有冲突，因此每次访问前都要取锁保证资源独占性，java中的synchronized、ReentrantLock等独占锁就是实现方式</p>
<p>乐观锁认为只需要在更新前检查是否有线程同时修改，没冲突就修改，有冲突就重复尝试或放弃。原子性CAS操作就是一种实现方式。</p>
<p>乐观锁通常适用于读多写少的场景，因为在读操作中不需要获取锁，只有在写操作时才需要进行冲突检测和解决，并发性能比悲观锁好。悲观锁通常适用于写多的场景，因为它确保了在任何时候只有一个线程能够访问共享资源，从而保证了数据的一致性。</p>
<p><strong>java线程池参数及工作机制</strong></p>
<p>核心线程数、最大线程数、空闲线程存活时间、时间单位</p>
<p>等待队列workQueue、线程工厂、handler拒绝策略</p>
<p><strong>等待队列分为三种</strong>：</p>
<p>无缓存等待队列，也就是说只要核心线程数小于最大数，一旦有任务等待就直接创建线程</p>
<p>有界缓存队列，缓存一定任务，超出缓存而最大线程数没满，创建线程</p>
<p>无界缓存队列，不会创建新线程，任务数无限缓存</p>
<p><strong>handler拒绝策略是队列满了并且核心线程数到达最大线程数时，如何处理：</strong></p>
<p>默认抛出拒绝执行异常，还有</p>
<p>discardpolicy，直接丢弃任务</p>
<p>DiscardOldestPolicy，抛弃等待队列中等待最久的任务，然后把当前任务加入等待队列，CallerRunsPolicy，将多出来的任务退还给调用者，从而降低流量。</p>
<p><strong>线程池工作过程？</strong></p>
<ol>
<li>当调用 execute() 方法添加一个任务时，线程池会做如下判断：</li>
</ol>
<p> a) 如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；</p>
<p> b) 如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；</p>
<p> c) 如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；</p>
<p> d) 如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会抛出异常 RejectExecutionException。</p>
<ol start="2">
<li><p>当一个线程完成任务时，它会从队列中取下一个任务来执行。</p>
</li>
<li><p>当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。</p>
</li>
</ol>
<h2 id="JavaWeb后端"><a href="#JavaWeb后端" class="headerlink" title="JavaWeb后端"></a>JavaWeb后端</h2><blockquote>
<p>🔎<a target="_blank" rel="noopener" href="https://www.cnblogs.com/chuonye/p/10846998.html">Tomcat 中的 Session 和 Cookie</a></p>
</blockquote>
<h3 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h3><p>其实就是个软件服务器，你的java项目部署到这上面，他帮你处理和外界的连接</p>
<p>但好像现在有了SSM框架，很少有人直接使用tomcat，因为springboost里有内置，人家已经包装好了。</p>
<p>Tomca可以分为两大部分：连接器和容器，连接器专门用于处理网络连接相关的事情，如Socket连接、request封装、连接线程池维护等工作，容器用来存放我们编写的网站程序，Tomcat中一共有4层容器：Engine、Host、Context和Wrapper。一个Wrapper对应一个Servlet，一个Context对应一个应用，一个Host对应一个站点，Engine是引擎，一个容器只有一个。Context和Host的区别是Host代表站点，如不同的域名，而Context表示站点下的一个应用。一套容器和多个连接器组成一个Service，一个Tomcat中可以有多个Service。</p>
<img src="/2023/10/06/%E6%88%91%E7%82%BC%E9%BB%84%E9%87%91%E4%B8%B9%E4%B9%8BJAVA%E8%AF%9E%E7%94%9F/image-20230717132610123.png" class="" title="image-20230717132610123">

<blockquote>
<ul>
<li>cookies和session的关系</li>
</ul>
<p>Cookie通常用于在客户端存储一些用户相关的标识或信息，而Session则用于在服务器端存储用户的状态信息和会话数据。</p>
<p>通常，会话ID会存储在Cookie中，以便在用户的连续请求中标识和检索与其相关的会话数据。</p>
<p>当用户首次访问一个网站时，服务器会创建一个新的会话，并将会话ID存储在Cookie中，然后在以后的请求中使用该ID来检索或更新会话数据。</p>
<p>通过Cookie中的会话ID，服务器可以将用户与其相关的会话数据连接起来，实现用户状态的跟踪和管理。</p>
<ul>
<li><p>tomcat用什么记录用户信息，识别会话,看源码应该是cookie和session</p>
</li>
<li><p>用cookies的话怎么保证是安全的</p>
</li>
<li><p>收到、处理和回复过程中，什么情况下使用session</p>
</li>
<li><p>springboot中controller接收的参数是什么？返回的又是什么？</p>
</li>
</ul>
</blockquote>
<h3 id="Servlet-Jsp"><a href="#Servlet-Jsp" class="headerlink" title="Servlet &amp; Jsp"></a>Servlet &amp; Jsp</h3><p>JSP的引入在一定程度上解决了Servlet存在的缺点。它的实现理念是让每个Servlet只负责其对应的业务逻辑处理，让JSP负责用户的HTML显示，因此实现了业务逻辑与视图实现的分离，从而极大的提高了系统的可扩展性。</p>
<p>通过Servlet进行整个网站的开发是可以的。 不过在Servlet中输出html代码，特别是稍微复杂一点的html代码，就会给人一种很<strong>酸爽</strong>的感觉。</p>
<p>如果能够直接使用Html代码，然后在html中写java代码，就好了~</p>
<p>JSP … 就可以干这个事情。但现在JSP过时了，掌握Servlet就行</p>
<p><strong>Servlet</strong></p>
<p>servlet是Java中一种特殊的类， 主要负责接收用户请求HttpServletRequest，doGet()\doPost()方法中处理，HttpResponse响应。</p>
<ul>
<li>继承关系</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javax.servlet.Servlet接口</span><br><span class="line">    javax.servlet.GenericServlet抽象类</span><br><span class="line">        javax.servlet.http.HttpServlet抽象子类</span><br></pre></td></tr></table></figure>

<ul>
<li><p>生命周期</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>返回值</th>
<th>作用</th>
<th>时间</th>
</tr>
</thead>
<tbody><tr>
<td>init(config)</td>
<td>void</td>
<td>初始化</td>
<td>默认servlet第一次收到请求时启动，也可调整到tomcat初始化时就启动</td>
</tr>
<tr>
<td>service(request,response)</td>
<td>void</td>
<td>服务（重点）</td>
<td>之后的每一次服务都是调用service()，且一个servlet只有一个实例</td>
</tr>
<tr>
<td>destory()</td>
<td>void</td>
<td>销毁</td>
<td>容器关闭时所有servlet实例销毁</td>
</tr>
</tbody></table>
</li>
<li><p>你写的servlet主要就是负责实现<strong>service</strong>，如果你的servlet中没有实现覆盖方法，编译器就会动态获取最合适的方法，即父类httpservlet中的对应方法，但它没有实现，因此会有405错误</p>
</li>
<li><p>servlet是<strong>线程不安全</strong>的，servlet的生命周期交给web容器管理，容器在加载servlet时实例化，每当有请求时调用service方法，service方法会根据需求调用doGet或者doPost，所以一个servlet对应一个实例，但是一个请求对应一个线程，就会出现多个线程操作同一个实例的情况，导致servlet线程不安全的问题</p>
</li>
<li><p>没有一个方法能够彻底处理线程安全问题，最好减少使用全局变量，或者对变量做只读的修饰</p>
</li>
<li><p><strong>HTTP</strong>就是用来确定请求和响应格式的。常用HTTP1.1(长连接)，HTTP1.0(短连接)</p>
</li>
<li><p>HTTP是无状态的，即不记录会话状态，需要有会话跟踪技术来识别用户，有客户端会话技术cookie，和服务器端会话技术session</p>
</li>
<li><p><strong>视图模板技术</strong>，为了让数据库里的数据在网页上渲染展示，需要有thymeleaf把写好的页面和查询到的数据融合渲染。类似于elementui中的表格咯</p>
</li>
</ul>
<p>框架：半成品软件。可以在框架的基础上进行软件开发，简化代码。</p>
<p><strong>SSM与三层BS架构对应关系</strong></p>
<p>表现层————SpringMVC(view+controller)<br>业务层————手写需求<br>持久层————MyBatis<br>Spring则控制整个项目中对象的创建与管理。</p>
<h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><blockquote>
<p>🔎recommend：廖雪峰的spring开发</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7110415265271119880#heading-1">http请求从tomcat到springmvc的完整流程 - 掘金 (juejin.cn)</a></p>
</blockquote>
<p><strong>IOC</strong></p>
<ul>
<li>控制反转<ul>
<li>控制：对象创建</li>
<li>反转：由手动创建–&gt;直接向IOC容器获取对象，其中复杂的依赖关系交给IOC容器做</li>
</ul>
</li>
<li>自动装配<ul>
<li>IOC是一种设计思想，具体实现是DI依赖注入，在spring中使用autowire自动装配实现依赖注入😅</li>
<li>装配什么呢？你要求IOC容器创建的对象A的成员变量值</li>
<li>使用autowire属性配置，有3种方法，byname，bytype，constructor</li>
</ul>
</li>
<li>IOC &amp; 工厂模式<ul>
<li><p>工厂模式是一种创建型模式，有工厂类一人负责创建产品(对象），其他类只需要提供产品订单(配置参数)直接向工厂获取即可</p>
</li>
<li><p>但IOC和工厂模式并非一致，工厂模式使用new创建对象，IOC使用反射机制创建</p>
</li>
<li><p>bean放在IOC容器中，是IOC容器(beanfactory)管理的组件，测试类通过IOC容器获取和操作bean</p>
</li>
<li><p>IOC有两种方式识别和管理bean：XML文件和annotation注解</p>
</li>
<li><p>常用注解：**@Component：将类标识为普通组件** @Controller：将类标识为控制层组件 @Service：将类标 识为业务层组件 @Repository：将类标识为持久层组件</p>
</li>
<li><p>@Component注解相当于定义了一个Bean</p>
</li>
<li><p>@Autowired就相当于把指定类型的Bean注入到指定的字段中</p>
</li>
</ul>
</li>
</ul>
<p><strong>AOP</strong></p>
<ul>
<li>本质就是动态代理，让spring自动为对象加个代理类进行统一业务管理</li>
<li>动态代理就是运行时动态生成代理类</li>
<li>在Java平台上对于AOP织入有3种方式，编译时、类加载时、运行时</li>
<li>spring中的aop是运行时织入，对接口类型使用JDK动态代理，对普通类使用CGLIB创建子类。如果一个Bean的class是final，Spring将无法为其创建子类。</li>
<li>AOP使用场景，如日志、安全检查、事务</li>
<li>Spring通过CGLIB创建的代理类，<strong>不会初始化</strong>代理类自身<strong>继承的任何成员变量</strong>，包括final类型的成员变量</li>
<li>总之还是OOP的思想：proxy类只承诺了要代理目标类的public方法，所以理论上一切的交互都应该被限制在被代理的方法集合里，不应该越过proxy的接口而直接交互。如果有新增的交互需求，都应该被统一到这个“被代理的方法集合”里去。</li>
</ul>
<p><strong>数据库</strong></p>
<ul>
<li><p>在Spring使用JDBC，首先我们通过IoC容器创建并管理一个<code>DataSource</code>(数据库连接池)实例，然后，Spring提供了一个<code>JdbcTemplate</code>，可以方便地让我们操作JDBC，因此，通常情况下，我们会实例化一个<code>JdbcTemplate</code>。顾名思义，这个类主要使用了Template模式</p>
</li>
<li><p>声明式事务</p>
<ul>
<li><p>实现事务的方式有编程式和声明式，编程式就是由程序员手动、反复写事务开启、运行、提交，而声明式是由框架的事务管理器进行管理，本质就是AOP场景的应用</p>
</li>
<li><p>声明式事务_属性1_传播等级：会遇到事务传播的问题，即一个事务调用另一个事务，这时是认为一个事务还是两个事务，这里可通过propagation参数设置，常为默认的REQUIRED，它的意思是，如果当前没有事务，就创建一个新事务，如果当前有事务，就加入到当前事务中执行。</p>
</li>
<li><p>除此还有属性，隔离等级、只读、超时、回滚</p>
</li>
</ul>
</li>
<li><p>DAO 数据访问层</p>
<ul>
<li>其实就是一个用于处理数据库字段、调用JdbcTemplate执行CRUD的类</li>
</ul>
</li>
<li><p>ORM-集成Mybatis</p>
<ul>
<li>Object-Relational Mapping：把关系数据库的表记录映射为Java对象</li>
<li>ORM框架有Hibernate、JAP…用他们可以替代JdbcTemplate</li>
<li>MyBatis是一个半自动化的ORM框架，需要手写SQL语句，没有自动加载一对多或多对一关系的功能。</li>
<li>使用Mybatis，业务逻辑主要就是通过<code>XxxMapper</code>定义的数据库方法来访问数据库</li>
</ul>
</li>
</ul>
<h3 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h3><p>Spring MVC是<strong>Spring框架的一个模块</strong>，用于构建基于Java的Web应用程序。</p>
<p>本质是一个servlet：</p>
<blockquote>
<ul>
<li>读取客户端（浏览器）发送的显式的数据。这包括网页上的 HTML 表单，或者也可以是来自 applet 或自定义的 HTTP 客户端程序的表单。</li>
<li>读取客户端（浏览器）发送的隐式的 HTTP 请求数据。这包括 cookies、媒体类型和浏览器能理解的压缩格式等等。</li>
<li>处理数据并生成结果。这个过程可能需要访问数据库，执行 RMI 或 CORBA 调用，调用 Web 服务，或者直接计算得出对应的响应。</li>
<li>发送显式的数据（即文档）到客户端（浏览器）。该文档的格式可以是多种多样的，包括文本文件（HTML 或 XML）、二进制文件（GIF 图像）、Excel 等。</li>
<li>发送隐式的 HTTP 响应到客户端（浏览器）。这包括告诉浏览器或其他客户端被返回的文档类型（例如 HTML），设置 cookies 和缓存参数，以及其他类似的任务。</li>
</ul>
</blockquote>
<p>总的来说，servlet就是运行在服务端上的程序，处理用户请求。</p>
<p>Spring Web 模型-视图-控制器 (MVC) 框架是围绕处理所有 HTTP 请求和响应的 DispatcherServlet 设计的，也就是说一个SpringMVC就是一个servlet，至于controller、view、service这些只是程序里的小组件</p>
<img src="/2023/10/06/%E6%88%91%E7%82%BC%E9%BB%84%E9%87%91%E4%B8%B9%E4%B9%8BJAVA%E8%AF%9E%E7%94%9F/spring_dispatcherservlet.png" class="" title="spring_dispatcherservlet">

<p>具体工作内容：</p>
<ul>
<li>收到 HTTP 请求后，DispatcherServlet 会咨询 <strong>HandlerMapping</strong> 以调用适当的 Controller。</li>
<li>控制器接受请求并根据使用的 <strong>GET</strong> 或 <strong>POST 方法</strong> 调用适当的服务方法。服务方法将根据定义的业务逻辑设置模型数据，并将视图名称返回给 DispatcherServlet。</li>
<li>DispatcherServlet 将获得 <strong>ViewResolver</strong> 的帮助来获取请求的定义视图。(如果前后端分离，就不需要这步，直接返回json格式的数据即可)</li>
<li>一旦视图完成，DispatcherServlet 将模型数据传递给视图，最终在浏览器上呈现。</li>
</ul>
<h3 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h3><ul>
<li><p>基于Spring提供的一组开箱即用的套件，助力少量配置+快速开发</p>
</li>
<li><p>相对于spring，做了更多封装，增加强大的AutoConfiguration功能，这是通过自动扫描+条件装配实现</p>
</li>
<li><p>REST请求接口</p>
<ul>
<li>form-data: &#x2F;&#x2F;localhost:8080&#x2F;users&#x2F;?id&#x3D;5&amp;userName&#x3D;xx 后台接收参数时使用注解@RequestParam</li>
<li>content-type: 参数以json形式传递，后台获取参数时使用注解@RequestBody</li>
</ul>
</li>
</ul>
<h3 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h3><p>核心 4 parts：</p>
<ul>
<li>SqlSessionFactoryBuilder：一旦创建了SqlSessionFactory，就不需要它了。</li>
</ul>
<p>所以比较适合在局部变量中创建。</p>
<ul>
<li>SqlSessionFactory：</li>
<li>SqlSessionFactory：相当于数据库的连接池。一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。所以SqlSessionFactory比较适合应用作用域，也就是全局。最简单的就是使用单例模式或者静态单例模式。</li>
<li>SqlSession：连接到连接池的一个请求。因为它不是线程安全的，不能共享。用完之后必须要关闭，否则资源被占用。因此它的作用域是请求或者方法作用域。</li>
<li>mapper：会话调用的方法</li>
</ul>
<img src="/2023/10/06/%E6%88%91%E7%82%BC%E9%BB%84%E9%87%91%E4%B8%B9%E4%B9%8BJAVA%E8%AF%9E%E7%94%9F/1111.png" class="">

<p>在spring中使用mybatis，可以简化好多代码，比如SqlSessionFactory、SqlSession、mapper的对象创建可以直接扔给IOC容器做，你只需要直接使用mapper就行，而不需要反复创建和手动管理之间的依赖关系，赞😘</p>
<h2 id="JAVA高级"><a href="#JAVA高级" class="headerlink" title="JAVA高级"></a>JAVA高级</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><strong>二叉搜索树</strong></p>
<p>左孩子比父节点小，右孩子比父节点大。中序遍历可以让结点有序。</p>
<p><strong>完全二叉树</strong></p>
<p>只有最下面两层结点的度可以小于2，并且最下一层的叶结点集中在靠左的若干位置上</p>
<p><strong>平衡二叉树</strong></p>
<p>左右子树的高度差最多为1</p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>动态规划</p>
<ul>
<li>适合解决 在约束条件下 存在重叠子问题 的最优解 问题</li>
<li>dp数组：当前结果只看之前的积累和当前新加入的比对最优解</li>
<li>空间换时间，减少重复计算，每一步都进行某项重复步骤，自底向上</li>
<li>经典题<ul>
<li>斐波那契数列</li>
<li>爬楼梯</li>
<li>01背包<ul>
<li>倒序：因为每个物品只能装1个，当前容量可装物品是基于之前物品和这次物品，但都只有一个</li>
<li>求当前容量下最大价值：dp[j] &#x3D; Math.max(dp[j], dp[j-weight[i]]+value[i])</li>
<li>求当前容量下最多组合数：dp[j] +&#x3D; dp[j-weight[i]]</li>
</ul>
</li>
<li>完全背包<ul>
<li>顺序：每个物品可以重复装，在更大的容量里可以再装一个当前物品，当前容量可装物品是基于之前物品总数量和这次物品数量</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>回溯</p>
<ul>
<li>暴力穷举</li>
<li>分岔路试探，当探索到某一步停止，原路返回继续走另一条路</li>
<li>经典题<ul>
<li>全排列</li>
<li>N皇后：这种多维问题总是会混乱，学会一维作为已知从而降为一维的思考方式</li>
</ul>
</li>
</ul>
<h3 id="✨Java常用语法汇总"><a href="#✨Java常用语法汇总" class="headerlink" title="✨Java常用语法汇总"></a>✨Java常用语法汇总</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//compareTo</span></span><br><span class="line">对于string类中的compareTo方法，比较两字符串的逻辑是，比较第一个不同unicode码的那位，返回差值</span><br><span class="line">    </span><br><span class="line"><span class="comment">//String.valueOf</span></span><br><span class="line">转换成string</span><br><span class="line">    </span><br><span class="line"><span class="comment">//自定义多维数组排序</span></span><br><span class="line">Arrays.sort(list, (x,y)-&gt;&#123;</span><br><span class="line">    x[<span class="number">0</span>]!=y[<span class="number">0</span>]?y[<span class="number">0</span>]-x[<span class="number">0</span>]:x[<span class="number">1</span>]-y[<span class="number">1</span>]</span><br><span class="line">&#125;)</span><br><span class="line">分析源码，发现时当y[<span class="number">0</span>]&gt;x[<span class="number">0</span>]时交换，也就是说这里的处理逻辑时当x[<span class="number">0</span>] ==y[<span class="number">0</span>]时，按<span class="number">1</span>的升序排序</span><br><span class="line">    </span><br><span class="line"><span class="string">&quot;&gt;&gt;&gt;&quot;</span>无符号右移</span><br><span class="line">操作规则：无论正负数，前面补零。</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&gt;&gt;&quot;</span>右移</span><br><span class="line">操作规则：正数前面补零，负数前面补<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&lt;&lt;&quot;</span>左移</span><br><span class="line">操作规则：无论正负数，后面补零。</span><br><span class="line">   </span><br><span class="line"><span class="type">boolean</span> 是 Java 的基本数据类型，在“赋零值”阶段给属性赋 <span class="literal">false</span></span><br><span class="line">Boolean 是包装类，在“赋零值”阶段给对象赋 <span class="literal">null</span>，同时提供其他的方法</span><br><span class="line"></span><br><span class="line">HashMap: get put remove size containsKey containsValue </span><br><span class="line"><span class="title function_">collection</span><span class="params">(list, set, queue)</span>: add contains isEmpty remove size toArray</span><br><span class="line">Queue: element offer poll peek</span><br><span class="line">StringBuffer|StringBuilder(not safe) : append insert length delete getChars toString</span><br><span class="line"></span><br><span class="line">位运算常用: x&amp;(x-<span class="number">1</span>) --&gt; 每做一次该运算，x最末尾的<span class="number">1</span>消去</span><br></pre></td></tr></table></figure>

<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ul>
<li><p>单例模式</p>
<ul>
<li><p>一个类只允许有一个实例</p>
</li>
<li><p>方法是将构造方法私有，给一个加以判断后的方法对外</p>
</li>
<li><p>实现单例模式：除了最简单最开始new一个外，使用双重检查double-check，我们进行了两次if (singleton &#x3D;&#x3D; null)检查，这样就可以保证线程安全了。这样，实例化代码只用执行一次，后面再次访问时，判断if (singleton &#x3D;&#x3D; null)，直接return实例化对象。</p>
<p>使用volatile关键字是为了放止指令重排序，<a target="_blank" rel="noopener" href="https://blog.csdn.net/java_1996/article/details/87472644">volatile关键字在单例模式(双重校验锁)中的作用_volitile 单例_指月小筑的博客-CSDN博客</a></p>
<img src="/2023/10/06/%E6%88%91%E7%82%BC%E9%BB%84%E9%87%91%E4%B8%B9%E4%B9%8BJAVA%E8%AF%9E%E7%94%9F/222.png" class=""></li>
</ul>
</li>
<li><p>工厂模式</p>
<ul>
<li>在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。</li>
<li>如果需要向应用中添加一种新产品， 你只需要开发新的创建者子类， 然后重写其工厂方法即可。</li>
<li>子类创建者想要使用哪种方法，只需重写工厂方法，对接到产品接口下某个具体产品即可，创建者就像是个真实的工厂，流程大体不变，可能只是从橘子味棒棒糖改成了草莓味棒棒糖！提高了代码的复用性，也不避免了紧耦合</li>
</ul>
</li>
<li><p>观察者模式</p>
</li>
<li><p>适配器模式</p>
<ul>
<li>适配器可担任两个对象间的封装器， 它会接收对于一个对象的调用， 并将其转换为另一个对象可识别的格式和接口。</li>
</ul>
</li>
<li><p>代理模式</p>
<ul>
<li>当你希望在无需修改客户代码的前提下于已有类的对象上增加额外行为时， 该模式是无可替代的</li>
</ul>
</li>
</ul>
<h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><blockquote>
<p>🔎《深入理解Java虚拟机》</p>
<p>在认识Java的底层机制后会明白，Java的创作者是在创建一个世界，新生代出生在Eden里，长期存活进入老年代，之后是永久代，就像一个个真实对象。</p>
<p>还真有人写出了话本：<a target="_blank" rel="noopener" href="https://www.chanmufeng.com/posts/JVM/%E6%88%91%E6%98%AF%E4%B8%80%E4%B8%AA%E5%9E%83%E5%9C%BE.html">我是一个垃圾 | 蝉沐风 (chanmufeng.com)</a></p>
</blockquote>
<p>核心问题：JVM组成部分，各结构作用，与java程序运行起来的联系</p>
<img src="/2023/10/06/%E6%88%91%E7%82%BC%E9%BB%84%E9%87%91%E4%B8%B9%E4%B9%8BJAVA%E8%AF%9E%E7%94%9F/20446.png" class="" width="20446">

<p>JVM组成：类加载器、运行时数据区域、执行引擎、本地库接口 </p>
<p>运行时数据区域：</p>
<p>线程共享：堆、方法区</p>
<p>线程私有：PC、虚拟机栈、本地方法栈</p>
<p>堆，几乎所有的对象实例</p>
<p>方法区，class信息、常量池、静态变量、JIT编译代码缓存。永久代是 JDK 1.8 之前的方法区实现，JDK 1.8 及以后方法区的实现变成了元空间。</p>
<p>虚拟机栈，线程调用的方法中的局部变量表、操作数栈、方法出口</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6940567155494617102">JVM 三种常量池 - 掘金 (juejin.cn)</a></p>
<img src="/2023/10/06/%E6%88%91%E7%82%BC%E9%BB%84%E9%87%91%E4%B8%B9%E4%B9%8BJAVA%E8%AF%9E%E7%94%9F/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1N1bnNoaW5lb2U=,size_16,color_FFFFFF,t_70.png" class="" title="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1N1bnNoaW5lb2U&#x3D;,size_16,color_FFFFFF,t_70">

<p><strong>一个类创建的过程是怎么样的</strong>？</p>
<p>​	首先在方法区的常量池中找是否有该类的引用，被引用的这个类是否被加载，没有则类加载器从class文件读取并加载进方法区，同时在Java堆中划出固定大小装这个对象，如果垃圾回收器具有压缩整理功能，即堆内存空间是规整的，就使用指针碰撞，不规整就用空闲列表法。有了空间后进行初始化为零，因此Java使用对象前不需要手动初始化。接着设置对象头里装的元信息。最后执行构造方法里的赋值，创建完成！</p>
<p><strong>为什么叫堆</strong>？</p>
<p>这并不是数据结构中的堆含义。生活中堆一般都是凌乱的不工整的，因为java中这个区域经常增删，动态频繁，盖为此。</p>
<p><strong>垃圾回收机制</strong></p>
<p>Java对象的一生：我是一个java对象，我出生在Eden区，当 Eden 区分配没有足够的空间进行分配时，虚拟机将会发起一次 Minor GC，我就被迫去了Survivor区的“From”区，自从去了Survivor区，在这里生活非常不稳定。有时候在Survivor的“From”区，有时候在Survivor的“To”区，居无定所。直到我15岁的时候（默认15岁），就被分配到年老代那边，在这里人很多，并且年龄都挺大的。在年老代里，我生活了很久，每次GC年龄就+1，然后被回收。</p>
<p><strong>说说类加载过程</strong></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/33509426">面试官：请你谈谈Java的类加载过程 - 知乎 (zhihu.com)</a></p>
<p>类加载过程包括加载、连接、初始化</p>
<p>加载，把字节码文件加载进方法区中，同时在堆中生成class对象作为访问方法区类数据的接口。连接，包括验证、准备、解析。验证文件内容符合JVM规范，准备是为方法区的静态变量赋零或null，解析是把常量池中的符号引用替换成直接内存地址。最后初始化方法区的静态变量和静态方法。</p>
<p><strong>知道双亲委派机制吗</strong>？</p>
<p>还蛮简单的，就是在类加载的时候，怎么选择类加载器的解决方法。不同的类加载器加载同一个类结果是不同的，为了保证核心类的加载正确一致，选择类加载器时先交给父类加载，若一直到最顶都不能加载再往子类委派加载。</p>
<p><strong>为什么要将永久代替换成元空间</strong>？</p>
<p>永久代受JVM本身固定大小限制，元空间使用的是本地内存，放在元空间受的是可用内存限制，也就是说使用空间更大，出现溢出的几率更小，可加载的类更多。</p>
<p><strong>JVM哪些部分会触发OOM异常？导致JVM OOM异常的原因有哪些？</strong></p>
<p>OOM通常是发生在程序要申请更多内存时，无法满足需求时触发。</p>
<p>在OOM里，除了PC外，包括堆、方法区、虚拟栈、本地栈都会触发OOM异常</p>
<p>当堆中存储过多对象实例，超出了堆内存上限，就会触发</p>
<p>因为JDK1.8后方法区放进了本地内存，那当加载进太多类或者创建过多代理类时，超过了本地内存上限，也会触发</p>
<p>栈的话，当递归调用过深，会触发</p>
<p><strong>字符串常量池</strong></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7181322531863806007">正确理解和使用JAVA中的字符串常量池 - 掘金 (juejin.cn)</a></p>
<p>字符串常量池就是为了提高字符串的重用率，提高速度和内存使用效率。</p>
<p>两种方法创建字符串，一种字符串字面量，这种就是直接在常量池里创建，要么就直接返回常量池的地址引用，都是字面量或final变量拼接的话会在编译期优化成独个字面量，另一种就是new，这肯定会在堆中创建一个对象，如果常量池中已有这个字符串，就把char[]指向常量池地址，否则创建一个在常量池中</p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1686226">面试题系列第2篇：new String()创建几个对象？有你不知道的-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><blockquote>
<p>🔎<a target="_blank" rel="noopener" href="https://juejin.cn/post/6855129007336521741#heading-7">mysql事务和锁 </a>、<a target="_blank" rel="noopener" href="https://juejin.cn/post/6860252224930070536#comment">mysql三大日志</a>、JavaGuide的SQL语句执行过程部分</p>
</blockquote>
<p>重点：索引、事务、锁、日志、存储引擎</p>
<p><strong>主键索引</strong></p>
<p>InnoDB是以数据页为单位让内存与磁盘交互的，数据页默认为16kb。<strong>一个数据页</strong>里的记录是一个根据主键从小到大排序好的<strong>单向链表</strong>，也就是说InnoDB会根据记录的主键进行排序，没设置主键的表会自动给加上自增列作为主键，通过排好序的主键建立索引。</p>
<p>索引方法是把<strong>一个数据页</strong>里的记录分成若干组，每组最末也就是主键值最大的记录是组长，作为索引项提出来放进槽里，槽在物理上是连续的，因此访问彼此很快。最后通过二分法在槽上查找，再找对应组即可。</p>
<blockquote>
<p>因为记录是主键顺序排序的，不建议让UUID作为主键，因为这样免不了会从链表中间插入记录的情况</p>
</blockquote>
<p>当一个数据页不够用，那就需要用到多个页，<strong>数据页之间用双向链表</strong>连接这个时候想要快速定位到某个页，就需要对页做个索引，方法是把每个页中的第一个记录提出来作为目录项记录，这样不断汇总到最顶部的目录项数据页。在用的时候只需要从顶部的页往下二分查找即可。这样建立的树就是B+树，InnoDB称之为<strong>主键索引</strong>，InnoDB的主键索引是聚簇索引，而MyISAM中无论是主键还是非主键索引，都是非聚簇索引，”聚簇索引”，即索引项顺序和数据物理存放顺序是一致的，指针不会乱指，是聚成一束的。通过上面的建立过程知道，B+树的叶子节点存储了所有的用户记录，其他层节点存储的都是目录项记录</p>
<p>由于InnoDB会对主键进行排序，数据页间不是物理连续，因此记录们是单向链表，数据页们是双向链表连接</p>
<p>总结：InnoDB会自动为每个表建立主键索引，即一颗B+树，B+树的叶子节点存储了所有的用户记录</p>
<p><strong>普通索引</strong></p>
<p>普通索引，就是建立在其他列上的索引，如主键是id，你想要在name上建索引。如果普通索引也像主键索引一样每个叶子节点都存储用户记录数据，那你这张表就会重复记录数据占用空间很大。因此普通索引被设计成二级索引，也就是他的叶子节点存放的是索引列和主键，获得对应主键后再调用主键索引进行查找，即回表查询。而覆盖索引就是普通索引的叶子节点存的索引列和主键已经够用，不需要回表查询，如在name上建索引，那我select name就是覆盖索引，因为我只要求输出所有的name，没必要再回表查询</p>
<p><strong>联合索引</strong></p>
<p>就是对多个列一起的索引，如索引建在(name, phone)上，这时在name相同时才会对phone排序，因此phone是乱序的，这时若不遵循”最左原则”，会索引失效，也就是说如果你没有建立phone的索引，直接使用这个name_phone联合索引去查找phone，是找不到的。</p>
<p><strong>用B+树存储索引的原理和好处是什么？</strong></p>
<p>可以从几个维度去看这个问题，查询是否够快，效率是否稳定，存储数据多少，以及查找<br>磁盘次数，为什么不是二叉树，为什么不是平衡二叉树，为什么不是 B 树，而偏偏是 B+<br>树呢？</p>
<p>为什么不是一般二叉树？<br>如果二叉树特殊化为一个链表，相当于全表扫描。平衡二叉树相比于二叉查找树来说，查<br>找效率更稳定，总体的查找速度也更快。</p>
<p>为什么不是平衡二叉树呢？<br>我们知道，在内存比在磁盘的数据，查询效率快得多。如果树这种数据结构作为索引，那<br>我们每查找一次数据就需要从磁盘中读取一个节点，也就是我们说的一个磁盘块，但是平<br>衡二叉树可是每个节点只存储一个键值和数据的，如果是 B 树，可以存储更多的节点数<br>据，树的高度也会降低，因此读取磁盘的次数就降下来啦，查询效率就快啦。</p>
<p>那为什么不是 B 树而是 B+树呢？<br>1）B+树非叶子节点上是不存储数据的，仅存储键值，而 B 树节点中不仅存储键值，也会<br>存储数据。innodb 中页的默认大小是 16KB，如果不存储数据，那么就会存储更多的键<br>值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找<br>数据进行磁盘的 IO 次数有会再次减少，数据查询的效率也会更快。<br>2）B+树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的，链表连着的。<br>那么 B+树使得范围查找，排序查找，分组查找以及去重查找变得异常简单</p>
<p><strong>总结</strong></p>
<p>B+树是自平衡的树，能够避免在极端条件下退化成链表降低查询效率，其次B+树节点能放很多键值，使得树又矮又胖，能减少IO次数，提高查找速度，最后B+树的直接用叶子结点存储数据，那我只需要查一次树就够了，提高查找效率。这些优点使B+树等值查询和范围查询都很快</p>
<p><strong>什么是MySQL的索引失效，失效原因是什么？</strong></p>
<p>索引失效就是不走索引查找，直接进行全局扫描。</p>
<p>失效原因很多，这里是一些经典场景：</p>
<ol>
<li>用联合索引时不满足最左匹配原则</li>
<li>使用select*</li>
<li>LIKE模糊查询时模糊匹配符%在最左边</li>
<li>类型隐式转换</li>
<li>索引列参与运算、使用函数</li>
<li>使用OR时有条件没建索引</li>
</ol>
<p><strong>并发事务会有哪些问题</strong>？</p>
<p>脏写、脏读、不可重复读、幻读</p>
<p>脏写的问题太严重了，任何隔离级别都必须避免。其它无论是脏读，不可重复读，还是幻读，它们都属于数据库的读一致性的问题，都是在一个事务里面前后两次读取出现了不一致的情况。</p>
<p>4种隔离级别，InnoDB默认使用可重复读级别，就能解决幻读问题</p>
<p>隔离级别越高，并行度越低</p>
<p><strong>mysql中的并发事务控制方法有哪些？</strong></p>
<p>锁和MVCC</p>
<p>锁，有共享锁和排他锁，按粒度分有行级锁、表级锁</p>
<p>MVCC，多版本并发控制，就是记下数据的更新版本，用于解决读一致性问题</p>
<p>读-读 即并发事务同时访问同一行数据记录。由于两个事务都进行只读操作，不会对记录造成任何影响，因此并发读完全允许。</p>
<p>写-写 即并发事务同时修改同一行数据记录。这种情况下可能导致脏写问题，这是任何情况下都不允许发生的，因此只能通过<strong>加锁</strong>实现，也就是当一个事务需要对某行记录进行修改时，首先会先给这条记录加锁，如果加锁成功则继续执行，否则就排队等待，事务执行完成或回滚会自动释放锁。</p>
<p>读-写 即一个事务进行读取操作，另一个进行写入操作。这种情况下可能会产生脏读、不可重复读、幻读。最好的方案是<strong>读</strong>操作利用<strong>MVCC</strong>，<strong>写</strong>操作进行<strong>加锁</strong>。</p>
<p><strong>三大日志</strong></p>
<p>bin-log、redo-log、undo-log</p>
<p>bin-log：server层的日志，记录的是SQL语句的执行记录，用于主从复制</p>
<p>redo-log：重做日志，每条 redo 记录由“表空间号+数据页号+偏移量+修改数据长度+具体修改的数据”组成，即操作磁盘的记录，mysql设计了redo log，具体来说就是<strong>只记录</strong>事务对数据页做了哪些修改，这样就能完美地解决性能问题了(相对而言<strong>文件更小并且是顺序IO</strong>)</p>
<p>undo-log：回滚日志，是用来恢复异常的，在事务执行前先把操作持久化到硬盘写进undo-log，这个是MVCC实现的关建</p>
<p>后两个日志是InnoDB使用的，redo-log保证事务持久性，undo-log保证事务的原子性</p>
<p><strong>SQL语句在Mysql中的执行过程</strong></p>
<p>查询语句的执行流程如下：权限校验（如果命中缓存）—&gt;查询缓存—&gt;分析器—&gt;优化器—&gt;权限校验—&gt;执行器—&gt;引擎</p>
<p>更新语句执行流程如下：分析器—-&gt;权限校验—-&gt;执行器—&gt;引擎—redo log(prepare 状态)—&gt;binlog—&gt;redo log(commit 状态)</p>
<p><strong>Innodb有哪些索引类型？</strong></p>
<p>默认B+树索引，还有 全文索引、哈希索引</p>
<p>哈希索引仅仅能满足”&#x3D;”,”IN”和”&lt;&#x3D;&gt;”查询，不能使用范围查询</p>
<p><strong>三大范式</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39390545/article/details/115037994">面试又双叒叕被问到数据库三大范式，该怎么答才能让面试官认可呢_数据库三大范式 面试__陈哈哈的博客-CSDN博客</a></p>
<p><strong>谈谈SQL优化</strong></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/409390845">字节面试官：一条sql执行慢的原因？如何优化？ - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_53601359/article/details/115553449">Sql优化总结！详细！（2021最新面试必问）_sql优化面试题_笨笨杨的博客-CSDN博客</a></p>
<h3 id="sql常用语法汇总"><a href="#sql常用语法汇总" class="headerlink" title="sql常用语法汇总"></a>sql常用语法汇总</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">#开窗函数</span><br><span class="line"><span class="built_in">sum</span>()<span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> ... <span class="keyword">order</span> <span class="keyword">by</span> ...)</span><br><span class="line">只加<span class="keyword">partition</span>就是在每个分组内所有累加每个值一样，再加<span class="keyword">order</span> <span class="keyword">by</span>就是在组内排序，并从顺序累加，每个值不一致<span class="operator">-</span>https:<span class="operator">/</span><span class="operator">/</span>www.jianshu.com<span class="operator">/</span>p<span class="operator">/</span><span class="number">9</span>a86103bd2d3</span><br><span class="line"></span><br><span class="line">#<span class="keyword">UNION</span> 与 <span class="keyword">UNION</span> <span class="keyword">ALL</span> 的区别</span><br><span class="line">当使用 <span class="keyword">UNION</span> 时，MySQL 会把结果集中重复的记录删掉，而使用 <span class="keyword">UNION</span> <span class="keyword">ALL</span> ，MySQL 会把所有的记录返回，且效率高于 <span class="keyword">UNION</span>。</span><br><span class="line"></span><br><span class="line">#时间日期相关常用函数</span><br><span class="line"><span class="type">date</span>() #保留时间戳的年月日，相似的还有<span class="keyword">year</span>()等</span><br><span class="line">date_format(<span class="type">date</span>, <span class="string">&#x27;%Y-%m&#x27;</span>) #<span class="type">timestamp</span><span class="comment">--&gt;string,用于查看那天或那年等的记录咯</span></span><br><span class="line">date_add(<span class="type">date</span>,<span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">day</span>)#<span class="type">INTERVAL</span>表示间隔, <span class="keyword">day</span>可替换成其他时间单位,<span class="number">1</span>为任意整数</span><br><span class="line">datediff(startdate,enddate)#startdate<span class="operator">-</span>enddate 只能是<span class="keyword">day</span></span><br><span class="line">timestampdiff(<span class="type">interval</span>,startdate,enddate)#enddate<span class="operator">-</span>startdate 根据前面的<span class="type">interval</span>配</span><br><span class="line"></span><br><span class="line">#case...end</span><br><span class="line"><span class="keyword">case</span> </span><br><span class="line">    <span class="keyword">when</span> lastTime <span class="operator">&gt;</span><span class="number">29</span> <span class="keyword">then</span> <span class="string">&#x27;流失用户&#x27;</span></span><br><span class="line">    <span class="keyword">when</span> lastTime <span class="operator">&gt;=</span> <span class="number">7</span> <span class="keyword">then</span> <span class="string">&#x27;沉睡用户&#x27;</span></span><br><span class="line">    <span class="keyword">when</span> earlyTime <span class="operator">&lt;</span> <span class="number">7</span> <span class="keyword">then</span> <span class="string">&#x27;新晋用户&#x27;</span></span><br><span class="line">    <span class="keyword">else</span> <span class="string">&#x27;忠实用户&#x27;</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">as</span> user_grade</span><br><span class="line"></span><br><span class="line">#count和sum条件用法</span><br><span class="line">count看谁都是<span class="operator">+</span><span class="number">1</span>,除了<span class="keyword">NULL</span>，要想不计可以用<span class="built_in">count</span>((condition...) <span class="keyword">or</span> <span class="keyword">NULL</span>)</span><br><span class="line">或者用if嵌套：</span><br><span class="line"><span class="built_in">count</span>(if(condition...,<span class="number">1</span>,<span class="number">0</span>)) <span class="operator">|</span> <span class="built_in">sum</span>(if(condition...,<span class="number">1</span>,<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">#判断连续</span><br><span class="line">利用<span class="built_in">row_number</span>()<span class="operator">+</span>窗口函数比对实现</span><br><span class="line"><span class="comment">--&gt;牛客sql167 连续签到领金币题十分经典!</span></span><br><span class="line"></span><br><span class="line">#mysql执行顺序</span><br><span class="line"><span class="keyword">select</span>和<span class="keyword">order</span> <span class="keyword">by</span>最后执行</span><br><span class="line"><span class="number">1.</span> <span class="keyword">from</span>生成虚拟表</span><br><span class="line"><span class="number">2.</span> <span class="keyword">where</span>筛选虚拟表中符合条件数据</span><br><span class="line"><span class="number">3.</span> <span class="keyword">group</span> <span class="keyword">by</span>分组，之后只能使用<span class="keyword">group</span> <span class="keyword">by</span>子句中的列和聚合函数，这一步开始可以使用<span class="keyword">select</span>别名</span><br><span class="line"><span class="number">4.</span> 聚合函数，生成新虚拟表</span><br><span class="line"><span class="number">5.</span> <span class="keyword">having</span>筛选</span><br><span class="line"><span class="number">6.</span> <span class="keyword">select</span>筛选</span><br><span class="line"><span class="number">7.</span> <span class="keyword">distinct</span>筛选</span><br><span class="line"><span class="number">8.</span> <span class="keyword">order</span> <span class="keyword">by</span>排序</span><br><span class="line"><span class="number">9.</span> limit限定</span><br><span class="line"></span><br><span class="line">#<span class="keyword">using</span>和<span class="keyword">on</span></span><br><span class="line"><span class="keyword">using</span>是简化写法,<span class="keyword">using</span>(<span class="type">date</span>) <span class="operator">=</span><span class="operator">=</span> <span class="keyword">on</span>(t1.date<span class="operator">=</span>t2.date)</span><br><span class="line"></span><br><span class="line">#添加总计行</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span>的扩展，只需在<span class="keyword">group</span> <span class="keyword">by</span>语句之后加上<span class="keyword">with</span> <span class="keyword">rollup</span></span><br><span class="line"><span class="comment">-------------------------------------------------</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    productline, </span><br><span class="line">    <span class="built_in">SUM</span>(orderValue) totalOrderValue</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> </span><br><span class="line">    productline </span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    <span class="keyword">NULL</span>, </span><br><span class="line">    <span class="built_in">SUM</span>(orderValue) totalOrderValue</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    sales; </span><br><span class="line"><span class="comment">--------------------------------------等价于</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    productLine, </span><br><span class="line">    <span class="built_in">SUM</span>(orderValue) totalOrderValue</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> </span><br><span class="line">    productline <span class="keyword">WITH</span> <span class="keyword">ROLLUP</span>; </span><br><span class="line"><span class="keyword">rollup</span>会在每个列的分组结束后进行合计，合计列名称是<span class="keyword">NULL</span>，需要用IFNULL替换名字，使用示例:</span><br><span class="line"><span class="comment">--------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">select</span> ifnull(product_id,<span class="string">&#x27;店铺汇总&#x27;</span>)product_id, concat(round((<span class="number">1</span> <span class="operator">-</span> <span class="built_in">SUM</span>(in_price<span class="operator">*</span>cnt) <span class="operator">/</span> <span class="built_in">SUM</span>(price<span class="operator">*</span>cnt))<span class="operator">*</span><span class="number">100</span>,<span class="number">1</span>),<span class="string">&#x27;%&#x27;</span>)profile_rate</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span> product_id, in_price, price, cnt</span><br><span class="line">    <span class="keyword">from</span> (</span><br><span class="line">        tb_product_info </span><br><span class="line">        <span class="keyword">join</span> tb_order_detail <span class="keyword">using</span>(product_id)</span><br><span class="line">        <span class="keyword">join</span> tb_order_overall <span class="keyword">using</span>(order_id)</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">where</span> date_format(event_time,<span class="string">&#x27;%Y-%m&#x27;</span>)<span class="operator">&gt;=</span><span class="string">&#x27;2021-10&#x27;</span> <span class="keyword">and</span> shop_id<span class="operator">=</span><span class="number">901</span> <span class="keyword">and</span> status <span class="operator">=</span> <span class="number">1</span> </span><br><span class="line">) <span class="keyword">as</span> t1</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> product_id</span><br><span class="line"><span class="keyword">with</span> <span class="keyword">rollup</span></span><br><span class="line"><span class="keyword">having</span> profile_rate <span class="operator">&gt;</span> <span class="number">24.9</span> <span class="keyword">or</span> product_id <span class="keyword">is</span> <span class="keyword">null</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> product_id</span><br><span class="line">合计的计算方法是和每组聚合时一致，只是从每组内数据聚合编程组间聚合</span><br><span class="line"></span><br><span class="line">#字符串拼接</span><br><span class="line">concat(<span class="number">100</span><span class="operator">*</span>a,<span class="string">&#x27;%&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h2><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><p><strong>说说osi七层协议</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wwy0324/article/details/109310658">OSI七层模型、TCP&#x2F;IP四层模型（超详细！！！！！）_加油，你可以的！的博客-CSDN博客</a></p>
<p>应用层，因为不同应用实现的机制、收发的内容是不同的，因此对不同应用程序会有不同的协议，如浏览器是基于http，传文件是基于ftp，qq是基于oicq，内容不同，怎么传传什么不同，因此协议不同。</p>
<p>表示层，就是把数据表示出来，因为机器不同，数据表示不同，需要在统一格式和本地格式之间转换，如音乐二进制由mp3解码，jpeg有相应解码器解码表示。</p>
<p>会话层，管理建立、保持、断开会话过程，能不能建立(身份验证)？何时建立？何时断开？保持多久？SSL&#x2F;TSL</p>
<p>传输层，端到端传输，相比于网络层，加了端口号，TCP协议</p>
<p>网络层，主机到主机传输，IP协议</p>
<p>数据链路、物理层</p>
<p>那么实际使用的<strong>TCP&#x2F;IP模型</strong>，把上三层合并，下两层合并，共四层，应用层、传输层、网络层、物理层，下面是对这四层常问的问题，物理层一般不会问</p>
<p><strong>应用层</strong></p>
<p><strong>HTTP头信息都有什么？（发展过程）</strong></p>
<p><a target="_blank" rel="noopener" href="https://restfulapi.cn/archives/76">HTTP 协议入门 – RESTful API 一种流行的 API 设计风格</a></p>
<p><strong>RESTful架构是什么？</strong></p>
<p>是一种web软件设计风格，资源表示状态转换，他认为请求是向URI实体请求，发送的是不同的表示形式，客户端操作使得服务端上的资源状态发生改变。然后如果你的软件设计是符合这套风格的，那就是restful的</p>
<p><a target="_blank" rel="noopener" href="https://restfulapi.cn/archives/37">理解RESTful架构 – RESTful API 一种流行的 API 设计风格</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7051801217705443341">为什么少有人使用RESTful API？ - 掘金 (juejin.cn)</a></p>
<p><strong>从输入 URL 到页面展示到底发生了什么？</strong></p>
<p>简单来说，包括DNS查找IP地址，发送HTTP请求建立TCP连接，服务器处理请求，返回HTML响应，浏览器解析渲染。</p>
<p>DNS解析过程是，现在本地域名服务器查找有无缓存，没有就向根域服务器问，接着层层下问，最终返回，相当于一个递归过程</p>
<p><strong>http和https有什么区别？</strong></p>
<p>HTTP 默认是 80，HTTPS 默认是 443</p>
<p>HTTP是明文传输，HTTPS是在HTTP基础上添加了加密和认证机制，更加安全</p>
<p>HTTPS消耗更多内存和CPU资源</p>
<p>HTTPS通信需要证书，一般需要向颁发机构购买</p>
<p><strong>https怎么保证安全的？</strong></p>
<p>或者说是TLS握手过程，首先TLS是使用对称与非对称加密两种结合保证安全与性能的。</p>
<p>用户发送请求，服务端发送数字证书，证书里有服务端公钥，验证证书合法后，用户使用公钥加密本地生成的一个对称密钥，再用对称密钥加密报文摘要，发送两者给服务端，服务端解密对称密钥，通过解密报文验证，正确后返回对称密钥加密后的报文，用户确认后，握手结束</p>
<p>这里数字证书之所以可靠，是因为数字证书的公钥是操作系统本身会有预存的可靠CA的公钥，对应的数字证书只有CA用私钥签名后才能被解，因此证书里的服务端公钥是不可能被中途替换，除非CA被毁或私钥泄露</p>
<p><strong>Http常用状态码？</strong></p>
<p>200：成功，404：资源未找到，500：服务器内部错误</p>
<p><strong>Session和cookies是什么？</strong></p>
<p><strong>get和post区别是什么？</strong></p>
<p><strong>传输层</strong></p>
<p><strong>为什么建立连接要3次握手？为什么断开连接要4次握手？</strong></p>
<p>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</p>
<ol>
<li><strong>第一次握手</strong>：clinet发送syn，请求连接</li>
<li><strong>第二次握手</strong>：server 发送syn+ack，表示收到，同意连接</li>
<li><strong>第三次握手</strong>：client发送ack，表示收到，让server知道自己收到</li>
</ol>
<p>三次握手就能确认双方收发功能都正常，缺一不可。</p>
<p>断开一个 TCP 连接则需要“四次挥手”，缺一不可：</p>
<ol>
<li><strong>第一次挥手</strong>：c发送fin，请求关闭连接</li>
<li><strong>第二次挥手</strong>：s发送ack，告诉c自己收到</li>
<li><strong>第三次挥手</strong>：s讲完后，发送fin，表示可以关闭连接了</li>
<li><strong>第四次挥手</strong>：c发送ack，表示收到</li>
</ol>
<p>只要四次挥手没有结束，客户端和服务端就可以继续传输数据！</p>
<p><strong>TCP 与 UDP 的区别</strong></p>
<p>为什么HTTP采用TCP而不采用UDP作为底层协议？这其实就是在回答两者区别。</p>
<p>首先因为TCP是面向连接的，UDP在传输前不需要建立连接</p>
<p>其次UDP不保证数据的完整性和顺序性，TCP通过确认、重传等确保数据可靠，无差错、不丢失、不重复、并且按序到达。</p>
<p>TCP是有状态的，会记录自己的消息是否已发送、被接受，而UDP只管发送</p>
<p>TCP只支持点对点，UDP支持一对多、多对多</p>
<p>TCP传输效率会比UDP低，首部开销也更大</p>
<p><strong>网络层</strong></p>
<p>网关是什么？</p>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p><strong>怎么从用户态转到内核态？</strong></p>
<p>系统调用</p>
<p>用户态进程主动切换成内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，如fork()。系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现</p>
<p>中断</p>
<p>外围设备完成操作后向CPU发出中断信号，这时 CPU 会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</p>
<p>异常</p>
<p>当 CPU 在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。</p>
<h2 id="女娲补天"><a href="#女娲补天" class="headerlink" title="女娲补天"></a>女娲补天</h2><ul>
<li><p>解决哈希冲突</p>
<ul>
<li>hashmap–<strong>拉链法</strong></li>
<li>ThreadLocal–<strong>开放定址法</strong>(使用探测函数探测下一个位置直到空)</li>
</ul>
</li>
<li><p>CyclicBarrier &amp; CountDownLatch &amp; Semaphore</p>
<ul>
<li>CyclicBarrier用于等待一组线程达到共同屏障点</li>
<li>CountDownLatch用于等待特定数量的线程完成</li>
<li>Semaphore用于控制同时访问资源的线程数量</li>
</ul>
</li>
<li><p>String split 这个方法默认返回一个数组，如果没有找到分隔符，会把整个字符串当成一个长度为1的字符串数组返回到结果</p>
</li>
<li><p>Integer a &#x3D; 1;是自动装箱会调用Interger.valueOf(int)方法；该方法注释如下： </p>
<blockquote>
<p>  This method will always *** values in the range -128 to 127 inclusive, and may *** other values outside of this range. </p>
</blockquote>
<p>也就是说IntegerCache类缓存了-128到127的Integer实例，在这个区间内调用valueOf不会创建新的实例。</p>
</li>
<li><p>try..catch..finally…return</p>
<ul>
<li><p>finally一定会执行(你要说中途断电，或强制终止程序那另说)，如果finally中有return，会覆盖原try&#x2F;catch里的return值，但如果只是修改变量值，不会影响try&#x2F;catch中return的相应变量值</p>
</li>
<li><p>finally之后的语句是否执行，取决于前面try&#x2F;catch&#x2F;finally语句块中有没有return ，没有则继续执行</p>
</li>
</ul>
</li>
<li><p>this关键字作用</p>
<ul>
<li>区别成员变量和局部变量：this.age &#x3D; age</li>
<li>调用本类其他方法(不常用)</li>
<li>在构造方法中调用其他构造方法，避免重复代码。注意，this(a)只能放在构造方法首行</li>
<li>表示当前对象。一个类可以有多个对象，可通过this来区别当前是哪个对象</li>
</ul>
</li>
<li><p>linux-umask</p>
<ul>
<li>umask用于定义新建文件或目录的默认权限，chmod用于改变已有文件或目录权限</li>
<li>文件权限配置有10位长度，包括4段：<ol>
<li>文件类型(-文件，d目录，l链接文件…)</li>
<li>所有者权限(rwx)</li>
<li>所在组权限(rwx)</li>
<li>其他用户权限(rwx)</li>
</ol>
</li>
<li>umask &#x3D; 022，用<strong>777</strong>-022&#x3D;755，即111 101 101，也就是rwx r-x r-x</li>
</ul>
</li>
<li><p>策略模式</p>
<p>一种策略存在多种变体实现，那么只暴露策略接口，对具体多种实现封装，外部调用接口即可</p>
</li>
<li><p>观察者模式</p>
<ul>
<li>允许一个对象将其状态的改变通知给需要知道的对象。其实就是发布-订阅</li>
</ul>
</li>
<li><p>模板模式</p>
<ul>
<li>算法框架放在一个模板类，算法具体某个需要改动的方法由具体子类实现</li>
</ul>
</li>
<li><p>代理模式</p>
<ul>
<li>静态代理：静态代理的本质是由<strong>程序员</strong>创建或工具生成代理类的源码，再编译代理类。所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了</li>
<li>动态代理：动态代理类的源码是在程序运行期间由<strong>JVM</strong>根据反射等机制动态的生成，所以<strong>不存在</strong>代理类的字节码文件。代理类和委托类的关系是在程序运行时确定。</li>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1921291">什么静态代理？什么是动态代理？-腾讯云开发者社区-腾讯云 (tencent.com)</a></li>
</ul>
</li>
<li><p>方法重载</p>
<ul>
<li>方法签名&#x3D;方法名+参数类型、个数</li>
<li>JVM根据方法签名标识方法</li>
<li>只是返回值不同无法判断使用哪个方法，不是重载</li>
</ul>
</li>
<li><p><strong>Java创建对象有几种方式?</strong></p>
</li>
<li><p><strong>OOM SOF</strong></p>
</li>
<li><p><strong>List set map区别</strong></p>
</li>
<li><p>hashmap-concurrenthashmap</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/21673805">Java 8系列之重新认识HashMap - 知乎 (zhihu.com)</a></li>
</ul>
</li>
<li><p>lambda是Java8的新特性，允许方法作为参数传入，写法是(参数)-&gt;{方法语句}</p>
</li>
<li><p>匿名内部类，把子类继承父类&#x2F;具体类实现接口，实例化对象放在了一条语句，很简洁</p>
</li>
<li><p>说说乐观锁和悲观锁呗</p>
</li>
<li><p>Inter</p>
</li>
<li><p><strong>Java源码中直接出现的字符串</strong>，将会放在堆内存中的常量池里，存储在字符串常量池的字符串将<strong>不会被垃圾回收所清理</strong></p>
</li>
<li><p>new string 会创建几个对象实例？</p>
<p>“Java源码中直接出现的字符串将会放在堆内存中的常量池里”</p>
<ul>
<li>new string(“abcd”) –&gt;创建两个</li>
<li>new string(char[])–&gt;创建一个</li>
</ul>
</li>
<li><p>“str1+str2”&#x2F;“‘abc+”dfg’” 生成的string会进入常量池吗?</p>
<p>“+”运算本质上是new StringBuilder().append(…).toString()，得到的是string对象</p>
</li>
<li><p>intern，存引用还是存副本？</p>
<p>JDK1.7的改动：</p>
<ol>
<li>将String常量池 从 Perm 区移动到了 Java Heap区</li>
<li>String.intern() 方法时，如果存在堆中的对象，会直接保存对象的引用，而不会重新创建对象。</li>
</ol>
</li>
<li><p>JDK&lt; 开发工具，JRE&lt;运行类库，JVM&gt; &gt;</p>
</li>
</ul>
<h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><h3 id="充电桩"><a href="#充电桩" class="headerlink" title="充电桩"></a>充电桩</h3><p>背景：校园里新建充电站，2个快充桩，3个慢充桩，客户通过客户端申请充电，服务端根据快充还是慢充为用户调度到相应充电桩或等候区，调度策略是时间优先。充完电后生成账单。管理员端负责充电桩监控和修改计费规则。</p>
<p>日志系统？</p>
<blockquote>
<p>logback+lombok，logback是boot默认带的（web包里有starter,start里有logback），lombok配合实现@Slf4j注解标注类，比直接用logback简洁</p>
</blockquote>
<p>怎么做到到点自动结束？</p>
<blockquote>
<p>开5个线程，每个线程各自管理各自队列，把充电桩信息放在内存变量中存储，用while循环实时更新处理，充电时长即为线程睡眠时长，充电结束后生成账单并存入mysql</p>
</blockquote>
<p>spring与单例模式？</p>
<blockquote>
<p>SpringBoot采用的是单例模式、@Component注解默认实例化的对象是单例，如果想声明成多例对象，可以使用@Scope(“prototype”)</p>
<p>@Respository默认单例、@Service默认单例、@Controller默认单例</p>
</blockquote>
<p>spring的autowired究竟是什么？IOC有究竟是什么？</p>
<blockquote>
<p>现在看来spring的bean管理很大程度上就是用来解决单例模式下，共享变量的管理和使用问题，</p>
<p>IOC其实就是把管理和使用分离开，直接交由三方spring管理共享变量，使用者直接使用就行</p>
</blockquote>
<p>自动注入发现为null，没有注入成功？</p>
<blockquote>
<ol>
<li><p>对象是否有纳入容器管理@Component</p>
</li>
<li><p>被autowired的对象是否纳入容器管理@Component</p>
</li>
<li><p>new出来的数据，不被纳入容器管理，自然也就使用不了单例bean</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_28080659/article/details/99687074">解决SpringBoot中自己new出来的对象不能自动注入对象和属性的问题_new 出来的class注入不生效-CSDN博客</a></p>
</blockquote>
</li>
<li><p>被autowired的成员变量，为private的，是否有get&#x2F;set或@Data注解，因为java中的反射机制，获取不到private方法。</p>
<blockquote>
<p>原因：</p>
<p>因为代码里使用了SL4J日志，使用了aop，也就是使用动态代理，springboot底层默认调用的是cglib作为动态代理，其本质是：调用某个类的方法时，实际上是先为该类生成一个子类，然后再在子类中通过反射等，达到方法拦截的目的，对于子类，其父类中，private修饰的方法，子类如果与父类不在同一包下，是没有访问的权限的</p>
<p>此场景下，cglib生成的子类，不会和父类在同一包下，也就是private修饰的方法，不能进行动态代理，所以会报空指针异常。</p>
<p>若是不用AOP，就不会</p>
</blockquote>
</li>
</ol>
</blockquote>
<p>mybatis获取数据时，明明类和mysql里设定的类型均为spring，却无法接收？报错类型不一致？</p>
<blockquote>
<p>使用mybatis时，如果重写了实体类的有参构造方法，必须加上无参构造方法，否则会造成类型不一致无法接受数据的问题。</p>
<p>mybatis查完数据之后，会调用构造方法，默认会调用无参构造初始化对象，但是此处使用了工具自动生成无参构造，应该会正常调研，但我观看打包完的代码之后，发现打包编译好的代码里面并没有无参构造，原来，是下面这个有参构造的问题。</p>
<p>服了，一定要养成好习惯！不然就会白找问题1小时！</p>
</blockquote>
<p>并发环境下，for(String carId: car) 抛异常</p>
<blockquote>
<p>因为在循环过程中，有其他请求接入，queueSystem里会addCar，修改car数组，导致modcount前后不一致，增强for就会抛并发修改异常。也就是，虽然处理了生产者间的竞争、消费端的竞争，但生产者和消费者间的竞争没解决</p>
<p>解决方法：考虑到还会出现取号排号等场景同步修改queue的问题，这里改成使用JUC包下的并发队列解决，这里使用阻塞队列，由于读写频繁，队列长度不固定，读写分离锁性能更高，这里使用LinkedBlockingQueue</p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1706970">Java 7 种阻塞队列详解-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<p>aaaaa我有病，代码里的queue是我自己写的，实际上是操作ArrayList，退一步说，一个管理员同时监视两个队列也不能使用阻塞队列。考虑到出现生产者和消费者竞争，那我使用并发安全的ArrayList(同步包装器性能不高，pass) 或者用<strong>concurrentLinkedQueue</strong>（非阻塞、无界、CAS、性能最高）</p>
<p>🔎详细了解*整个项目用到的同步机制：</p>
<p>生产者端：用<strong>concurrentLinkedQueue</strong>非阻塞中的乐观锁<strong>CAS</strong>实现，遍历队列用<strong>Syntronized</strong>、进程状态await和对象wait区别、Integer里的初始化常量</p>
<p>消费者端：中央调度，不涉及并发竞争</p>
</blockquote>
<p>设计优化策略：</p>
<blockquote>
<ul>
<li><p>迁移至redis✔</p>
<p>车辆信息搬进redis里以键值形式存放，省去每一次在队列系统中的遍历，同时增加validate time，队列里不再存放car对象，只放carId。</p>
<p>考虑到hash不能设置过期时间，car的存储采用string键值存，设置有效时间为30*60，chargebill也采用string 存储</p>
</li>
<li><p>部署Linux✔</p>
<p>暂时无法直接测nginx的并发量</p>
</li>
<li><p>充电桩故障调度✔</p>
<p>线程同步-&gt;while修改参数，一旦检测到故障，跳出循环并交给队列系统进行优先级调度</p>
</li>
<li><p>线程策略优✔</p>
<p>n队列同步循环-&gt;改成单队列+叫号等待，运用线程池优势，while循环submit，从而在充电数小于桩数时，节省线程资源</p>
</li>
<li><p>接口日志统一记录✔</p>
<p>利用Aop切面织入所有控制器，环绕切入</p>
</li>
</ul>
</blockquote>
<p>用户量并发压力测试</p>
<blockquote>
<ul>
<li>线程池缓冲队列等参数最优值、定制tomcat</li>
</ul>
<p>线程数：1000，启动时间：3，循环次数：300</p>
<p>默认配置下的TPS：5000&#x2F;sec</p>
</blockquote>
<p>项目深挖</p>
<blockquote>
<ul>
<li><p>并发深造</p>
</li>
<li><p>框架深造</p>
<p>springboot的启动过程</p>
<p>mybatis详细原理</p>
</li>
</ul>
</blockquote>
<h3 id="用户购物行为数据分析"><a href="#用户购物行为数据分析" class="headerlink" title="用户购物行为数据分析"></a>用户购物行为数据分析</h3><p>Hadoop：Hadoop是一个分布式基础架构，核心包括HDFS分布式文件系统和Mapreduce批处理计算框架</p>
<p>HDFS：主从模型，由NameNode、DataNode和Client组成，NameNode负责管理文件信息，告诉client文件位置，DataNode负责存取文件数据，同时周期性把文件信息发送给NameNode。</p>
<p>MapReduce：分成两部分Map和Reduce，当你向MapReduce框架提交一个计算作业时，它会首先把计算作业拆分成若干个<strong>Map任务</strong>，然后分配到不同的节点上去执行，每一个Map任务处理输入数据中的一部分，当Map任务完成后，它会生成一些中间文件，这些中间文件将会作为<strong>Reduce任务</strong>的输入数据。Reduce任务的主要目标就是把前面若干个Map的输出汇总到一起并输出。</p>
<p>kafka：分布式消息队列，采用点对点模式，生产者push消息到集群的leader broker里，消费者主动pull拉取想要的消息。kafka是用来解决生产者和消费者解耦问题而出现的消息中间件</p>
<p>Hive：有点像myBatis，省去了写JDBC的麻烦，而Hive是个SQL语句解析引擎，省去了写MapReduce函数的麻烦，能直接用SQL语句进行数据处理，底层还是调用MP，当然也可以直接写MP程序查找，不过麻烦</p>
<p>难点：在写MP时，要想清楚怎么分配map给每个节点任务，以及最后reduce汇总后又要怎么做，以及要十分清楚计算引擎什么时候会调用map、reduce函数，这在给数据排序时候还挺关键</p>
<h2 id="敲好用的IDEA！"><a href="#敲好用的IDEA！" class="headerlink" title="敲好用的IDEA！"></a>敲好用的IDEA！</h2><ol>
<li>自动补全：输入new {class} + 按ctrl alt v</li>
<li>Ctrl+Alt+T，可以把代码包在一个块内，例如：try&#x2F;catch</li>
<li>输入iter&#x2F;fori按Tab</li>
</ol>
<h2 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/33988489">两年Java开发工作经验面试总结 - 知乎 (zhihu.com)</a></p>
<h2 id="经典面试寿司"><a href="#经典面试寿司" class="headerlink" title="经典面试寿司"></a>经典面试寿司</h2><ol>
<li>单例模式-懒汉式</li>
<li>常见排序</li>
<li>常见查找(二分查找、)</li>
<li>二叉树遍历(深度(前、中、后，栈)、广度(层序，队列))</li>
<li>翻转二叉树(每个节点左右子交换+深&#x2F;广遍历)</li>
</ol>
<h2 id="面试手握🤺"><a href="#面试手握🤺" class="headerlink" title="面试手握🤺"></a>面试手握🤺</h2><p><strong>美团 到店 充电宝 一面</strong></p>
<p>并发：怎么开启多线程，锁和syntronized关键字区别，用过哪些锁，主线程等待子线程方法，sleep()和wait()区别</p>
<p>基础：try catch finally顺序，volatile关键字，final关键字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>+<span class="string">&quot;b&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i4</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">System.out.println(i1 == i2); 	<span class="comment">//true</span></span><br><span class="line">System.out.println(i3 == i4); 	<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>Integer在-128~127间有缓存，当我们给Integer对象赋int值时会调用静态方法valueOf()。如果字面量的值在-128到127之间，那么不会new一个新的Integer对象，而是直接引用常量池里面的Integer对象</p>
<p>计网：输入URL地址后的过程，osi模型，http和https区别，https怎么实现安全性的，Session和cookies是什么，网关是什么</p>
<p>操作系统：怎么从用户态转到内核态</p>
<p>Redis：持久化方法</p>
<p>手撕：写单例模式，二分查找 </p>
<p><strong>美团 平台技术 一面</strong></p>
<p>操作系统：进程和线程区别、进程间通信方式</p>
<p>计网：OIS模型、tcp四次挥手、tcp怎么保证可靠、http的header都有什么、https建立连接过程</p>
<p>JVM：垃圾回收机制</p>
<p>两道逻辑思考题：无穷多的水，有5升桶和6升桶，怎么称出4升</p>
<p>25匹马，5个赛道，最少几次得出前三名</p>
<p>手撕：找出数组最大k个数</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/" rel="tag">JAVA</a></li></ul>

    </footer>
  </div>

    
 
   
  
</article>

    
    <article
  id="post-一根刺"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/27/%E4%B8%80%E6%A0%B9%E5%88%BA/"
    >一根刺</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/27/%E4%B8%80%E6%A0%B9%E5%88%BA/" class="article-date">
  <time datetime="2023-07-27T02:48:00.000Z" itemprop="datePublished">2023-07-27</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E4%BF%AE%E7%82%BC%E6%97%A5%E5%BF%97/">修炼日志</a>
  </div>
 
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>好像做错了一件事情，奈何手里没有纸笔</p>
<p>我找到了那根一直扎在脑子里的小刺，我明白是什么在压住我的胸口，让我越来越窒息和丑陋 </p>
<p>我忘了，什么是最重要的</p>
<p>这段时间很难熬，就像一只孤独的鲸丢失在茫茫大海，鲸声回鸣，就要溺水</p>
<p>每天太阳的东升西落是我最讨厌的事情，一天草草结束，却又在睁眼后再次要重复完全不喜欢做的事情。我就是一个靠感觉活着的怪物，我能感受到我不喜欢现在的生活，它是一滩烂水，没有激情也没有欲望。曾经美食会是救赎，但现在它不再能安慰到我。一口清泉再清，太久不没有活水流动，也会生脏长藻。现在我的心里就长了斑点，需要新的消毒水，挥发带来新生和空气。</p>
<p>我忘了，每年的假期回家，第一件事就是慢下来，慢下来，慢下来。这个过程会如百蚁挠心，因此第二件事就是找事情干，或者说，重回生活本身。</p>
<p>是啊，重回生活与生命本身</p>
<p>这个早就参悟的道理，这个刻在基因里的蝴蝶，此时正挥动翅膀告诉我，我忘了。</p>
<p>在学校里学习，总会让我加快加快再加快，快速在计算机行业这个信息爆炸的领域尤为明显，社交媒体的推动以及一样快速心流的周围朋友，整个环境都在告诉我要跑起来，停下来就是错误。碎片化信息和社会制造的焦虑就要把我拉下水了。 </p>
<p>感受，感受美丽的心情</p>
<p>感受珍贵新奇的感受，如果什么时候对这些不再需要，或许就是生命终结之时。</p>
<p>过去的20年里的孤独和隐忍，让我失去了爱人和被爱的能力，我的心中只有了自己，我向往外国人的性格外放爱憎分明，或许只需要踏出一步，也或许我注定如此 </p>
<p>生命的时间再次交回手上，我再次思考我喜欢什么，我要什么</p>
<p>但我十分清楚的是，毕业后我不会选择写代码，它确实是一门艺术，也许也很炫酷，是个能解决很多问题有用技术，但我无法从它身上获得除了脑子外的更多感受，比起脑子独自抽象的感受，我更喜欢手、脚、肌肤能触碰的真实，这才是我真正喜欢的感受，因此我喜欢唱歌、跑步、打球、游泳、健身、美食和徒步看美景</p>
<p>之前我会想，除了音乐我还喜欢什么？现在我想，除了音乐、运动，我还喜欢什么？ </p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%84%9F%E6%82%9F%E6%BB%9A%E5%AD%98/" rel="tag">感悟滚存</a></li></ul>

    </footer>
  </div>

    
 
   
  
</article>

    
    <article
  id="post-数据挖掘与数据仓库"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/02/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/"
    >数据挖掘与数据仓库</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/02/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/" class="article-date">
  <time datetime="2023-07-02T15:01:55.000Z" itemprop="datePublished">2023-07-02</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%90%8E%E5%A4%87%E7%AE%B1/">后备箱</a>
  </div>
 
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h4><p>机器学习更偏向理论算法，数据挖掘偏向具体场景应用</p>
<p>生成式模型</p>
<p>数据挖掘中的数据类型不同于程序设计</p>
<p>数据仓库相对于传统数据库，可以存储更多数据，对于表链接等操作更优</p>
<img src="/2023/07/02/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/rId20.png" class="">

<h4 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h4><p>OLAP(On-Line Analytical Processing)， OLTP(on-line transactionprocessing)，ETL</p>
<p>数据仓库、数据集市、数据湖</p>
<h4 id="Modeler"><a href="#Modeler" class="headerlink" title="Modeler"></a>Modeler</h4><p>根据卡方检验判断两属性值的相关性</p>
<p>相关性分析：矩阵可以看两个单拎出来的相关性，统计statistics可以看多个，更强！网络图看着很直观</p>
<h4 id="关联规则挖掘"><a href="#关联规则挖掘" class="headerlink" title="关联规则挖掘"></a>关联规则挖掘</h4><p>闭频繁项集理解就是X的出现不会伴有其他项集出现，X是闭频繁项集</p>
<h4 id="数据仓库"><a href="#数据仓库" class="headerlink" title="数据仓库"></a>数据仓库</h4><p>OLTP是传统的关系型数据库的主要应用，主要是基本的、日常的事务处理，例如银行交易。</p>
<p>OLAP是数据仓库系统的主要应用，支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果</p>
<p>数据仓库是建立在RDB上的，数据湖是NDB</p>
<h4 id="大作业准备"><a href="#大作业准备" class="headerlink" title="大作业准备"></a>大作业准备</h4><p>文本预处理：词袋预处理技术、TF-IDF预处理技术、Word2vec</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/53277723">NLP入门文本预处理Pre-processing</a></p>
<p>深度学习模型：RNN&#x2F;LSTM&#x2F;BERT&#x2F;GRU</p>
<p>经典分类算法：Bayesian、决策树、SVM、Logistic、KNN、xgboost</p>
<p>神经网络翻译：NMT</p>
<hr>
<h3 id="期末复习"><a href="#期末复习" class="headerlink" title="期末复习"></a>期末复习</h3><h4 id="数据挖掘部分"><a href="#数据挖掘部分" class="headerlink" title="数据挖掘部分"></a>数据挖掘部分</h4><ul>
<li><p>TF-IDF、word2vec (包括 knowledge graph embedding)</p>
<ul>
<li><p>TF-IDF( term frequency - inverse document frequency )</p>
<ul>
<li><p>根据字词(term)的在文本中出现的次数和在整个语料文档中出现的频率来计算一个字词在整个<br>语料中的重要程度</p>
</li>
<li><p>优点是能过滤掉一些常见的却无关紧要的词语，同时保留影响整个文本的重要字词</p>
</li>
<li><p>计算</p>
<ol>
<li><p>TF: 计算某个词在当前文章中出现的频率</p>
</li>
<li><p>IDF: log(语料库文档数&#x2F;包含该词的文档数+1)</p>
</li>
</ol>
<ul>
<li>当一个单词在更多的文档中出现时，它的IDF值会减小，表示它的重要性较低；而当一个单词在较少的文档中出现时，它的IDF值会增加，表示它的重要性较高。</li>
</ul>
<ol start="3">
<li>TF-IDF: TF*IDF</li>
</ol>
</li>
<li><p>某个词在文章中的TF-IDF越大，那么一般而言这个词在这篇文章的重要性会越高</p>
</li>
</ul>
</li>
<li><p>Word2vec</p>
<ul>
<li><p>用一个神经网络获得词向量</p>
</li>
<li><p>在Word2Vec中，使用负采样可以加速训练过程，并且可以避免<strong>梯度消失</strong>问题。负采样是一种优化技术，它通过仅更新一小部分相关的权重来近似计算整个模型的梯度。这样可以避免梯度消失问题，并且提高了训练的效率。</p>
<p>分为CBOW和Skip-gram两种方式</p>
</li>
</ul>
<img src="/2023/07/02/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/rId30.so" class="">
</li>
<li><p>知识图谱嵌入</p>
<ul>
<li><p>把关系图用向量形式表示</p>
</li>
<li><p>三元组（头实体，关联种类，尾实体）</p>
</li>
<li><p>打分函数，越大越接近事实，直到训练出最接近事实的三元组的三个向量表示，以此达到嵌入作用</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>循环神经网络 (包括 RNN、LSTM、GRU三个序列模型，与CNN卷积模型相对)</p>
<ul>
<li><p>RNN</p>
<ul>
<li><p>输入x词向量，根据上一个单元的状态信息a和当前输入x，生成当前状态信息a,以及当前单元输出y</p>
</li>
<li><p>RNN一个最大的缺陷就是<strong>梯度消失与梯度爆炸问题，</strong><br>由于这一缺陷，使得RNN在长文本中难以训练，<br>这才诞生了LSTM及各种变体</p>
</li>
<li><p>如果在训练过程中发生了梯度消失，这也就意味着我们的权重无法被更新，最终导致训练失败。而梯度爆炸所带来的梯度过大，从而大幅度更新网络参数，造成网络不稳定（可以理解为梯度步伐太大）。在极端情况下，权重的值变得特别大，以至于结果会溢出（NaN值）</p>
</li>
<li><p>也就是说RNN只有短期记忆</p>
</li>
</ul>
</li>
<li><p>LSTM</p>
<ul>
<li><p>为了增长记忆，引入遗忘门，输入门，输出门，也就是记住重要的，遗忘不重要的</p>
</li>
<li><p>GRU（Gate Recurrent<br>Unit）是LSTM的变体，只有两个门，遗忘门和输入门，决定丢掉哪些不重要的旧信息，决定记住哪些重要的新信息，结构更简洁，计算更高效，相对于LSTM来说，更受欢迎。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Transformer(包括 attention 机制)</p>
<p>变形金刚是更强大的序列模型，具体的模型有BERT、GPT等</p>
<p>虽然LSTM能使参考窗口长于RNN，但仍然是有限的，而注意力机制，在理论上并且计算资源充足时，具有无限长参考窗口，因此能在生成文本时使用整个故事的上下文</p>
<p>变形金刚模型包括两部分，encoding和decoding。</p>
<p>首先输入信息进入输入嵌入层，将信息和信息位置转换成向量表示，然后进入编码器层，编码器接收源语言句子并生成一个固定长度的表示，称为”上下文向量”或”思维向量”，它捕捉了输入句子的语义含义。解码器接收这个上下文向量，并逐词生成翻译句子。</p>
<p>变形金刚的关键在于自注意力机制</p>
<p>Attention本质上就是通过加权实现对全文感知。而Self-attention自注意力机制之所以称为&quot;自注意力&quot;，是因为它在计算注意力权重时不需要外部的查询向量，而是通过学习输入序列内部的关系来自我注意到不同位置之间的相关性。</p>
<p>NMT 神经机器翻译是一种利用人工神经网络将文本从一种语言翻译成另一种语言的方法。近年来，由于其能够产生高质量的翻译，NMT引起了广泛关注和普及。NMT系统的核心是一个神经网络模型，通常基于循环神经网络（RNNs）或更先进的Transformer架构。</p>
</li>
<li><p>GAN，以达到deep fake</p>
<p>生成对抗网络（GAN）是一种机器学习模型，由生成器和判别器两个互相对抗的网络组成。</p>
<p>GAN的目标是通过让生成器生成逼真的样本来学习数据的分布，并且让判别器能够准确地区分生成的样本和真实的样本。</p>
<p>生成器网络的作用是将输入的噪声向量转化为与真实数据相似的样本。它通过学习生成的样本与真实样本之间的分布特征来逐渐提高生成样本的质量。生成器通常采用深度神经网络，如卷积神经网络（CNN）或递归神经网络（RNN）。</p>
<p>判别器网络的作用是评估输入的样本是真实样本还是生成样本。它通过学习将生成的样本与真实样本区分开来，并给出一个概率分数。判别器也采用深度神经网络，通常是CNN或MLP（多层感知器）。</p>
<p>GAN的训练过程是一个博弈过程。生成器和判别器通过对抗的方式进行训练，不断优化各自的性能。生成器试图生成更逼真的样本以欺骗判别器，而判别器则努力提高对生成样本和真实样本的判别能力。</p>
<p>训练过程中，生成器和判别器的损失函数是相互关联的。生成器的目标是最小化判别器将生成样本判别为假的概率，而判别器的目标是最大化正确判别真实样本和生成样本的概率。</p>
<p>通过反复迭代训练，生成器和判别器逐渐提高各自的性能，直到达到一种动态平衡状态，使得生成器能够生成逼真的样本，而判别器无法准确判别生成样本和真实样本。</p>
</li>
</ul>
<h4 id="数据仓库部分"><a href="#数据仓库部分" class="headerlink" title="数据仓库部分"></a>数据仓库部分</h4><ul>
<li><p>绪论</p>
<p>掌握基本概念</p>
<ul>
<li><p>数据，时可以被计算机加工的”原材料”数据也可以是文字、图像、声音、网页等。</p>
</li>
<li><p>数据仓库是一个<strong>面向主题的、集成的、相对稳定的、反映历史变化的</strong>数据集合，用于支持管理决策。</p>
</li>
<li><p>多维分析 OLAP&#x2F;OLTP</p>
<ul>
<li><p>OLAP 在线分析处理（Online Analytical Processing）</p>
</li>
<li><p>OLTP在线事务处理（Online Transaction<br>Processing）。它是一种处理实时交易和业务操作的技术和系统。</p>
</li>
<li><p>区别：</p>
<ol>
<li><p>目的和应用领域：OLTP用于处理实时的交易和业务操作，例如在电子商务网站上下订单、进行库存更新等。而OLAP主要用于分析和探索数据以支持决策制定，如生成报表、执行复杂的数据分析和预测等。</p>
</li>
<li><p>数据结构和设计：OLTP系统通常基于关系数据库，其中数据以规范化的形式存储，以支持高效的事务处理。相比之下，OLAP系统使用多维数据结构，如立方体，以提供快速的分析和查询性能。</p>
</li>
<li><p>查询类型：OLTP系统处理大量的简单事务查询，如插入、更新和删除数据。而OLAP系统则更适合复杂的分析查询，需要对大量数据进行汇总、切片、钻取等操作。</p>
</li>
</ol>
</li>
<li><p>联系：</p>
<ol>
<li><p>数据源：OLAP系统通常需要从OLTP系统中获取数据，因为OLTP系统是实际交易和操作的来源。OLAP系统可以将OLTP系统中的数据抽取、转换和加载到其多维数据结构中，以进行更深入的分析和报告。</p>
</li>
<li><p>数据一致性：由于OLTP系统处理实时交易，因此数据的一致性和准确性对于OLTP系统至关重要。OLAP系统在数据导入过程中也要确保数据的一致性，以保证分析结果的准确性。</p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>数据挖掘</p>
<ul>
<li>概念</li>
</ul>
<p>数据挖掘就是从<strong>大量的、不完全的、有噪声的、模糊的、随机的</strong>数据中，提取隐含在其中的、人们事先不知道的、但又是潜在有用的信息和知识的过程。</p>
<ul>
<li>基本过程</li>
</ul>
</li>
</ul>
<p>数据挖掘和DW&amp;DM系统有密切的关系。数据挖掘是从大量的数据中发现模式、关联、趋势和隐藏的信息的过程。DW&amp;DM系统为数据挖掘提供了必要的数据基础和分析环境。数据集市（DataMart）是一个用于存储和管理特定业务领域的数据的子集的数据仓库。它是数据仓库（DataWarehouse）的一个组成部分，专门为满足某个特定业务部门或特定用途的数据分析和报告需求而设计。</p>
<ul>
<li><p>DW&amp;DM 系统应用框架</p>
<p>  DW (Data Warehouse) 和 DM (Data Mart)是数据仓库和数据集市的概念。它们是用于组织和管理企业数据的系统，以支持分析和决策制定。应用框架是一种结构化的方法，用于指导设计和实施DW&amp;DM系统</p>
</li>
</ul>
<p><strong>以下是一个常见的DW&amp;DM系统应用框架的概述：</strong></p>
<p><strong>需求分析和规划</strong>：在这个阶段，确定DW&amp;DM系统的业务需求和目标。与业务部门合作，理解需要的数据内容、分析维度和报告需求。制定战略和规划，以确定系统的范围和目标。</p>
<p><strong>数据源集成</strong>：在这个阶段，收集和整合来自不同数据源的数据。这些数据源可能包括企业的操作系统、数据库、外部数据供应商等。数据集成可能涉及数据抽取、转换和加载（ETL）过程，以将数据转换为适合DW&amp;DM系统的结构。</p>
<p><strong>数据存储和管理</strong>：在这个阶段，将集成的数据存储在数据仓库和数据集市中。数据仓库是一个集成的、历史的、主题导向的数据存储，用于支持跨部门和全面的分析。数据集市是特定业务领域的子集，针对特定的分析需求。</p>
<p><strong>数据建模和设计</strong>：在这个阶段，设计DW&amp;DM系统的数据模型。常用的数据建模方法包括星型模型和雪花模型。这些模型定义了数据的结构、维度、指标和关系，以支持快速和灵活的查询。 </p>
<p><strong>数据访问和查询</strong>：在这个阶段，提供用户访问和查询DW&amp;DM系统的接口和工具。这可能包括查询和报告工具、在线分析处理（OLAP）工具、数据可视化工具等。用户可以通过这些工具执行自定义查询、生成报告和分析数据。</p>
<p><strong>数据质量和管理</strong>：在这个阶段，确保DW&amp;DM系统中的数据质量和一致性。进行数据清洗、验证和校准，以减少数据错误和不一致性。建立数据管理策略和规程，确保数据的完整性和可靠性。</p>
<p><strong>监控和维护</strong>：在这个阶段，监控DW&amp;DM系统的性能和运行情况。进行系统维护和优化，包括性能调整、容量规划、备份和恢复等。确保系统的稳定性和可靠性。</p>
<p>对于结构化和非结构化的数据，又有不同的挖掘方法，后面学到的神经网络方法，都是在处理非结构化的复杂数据，而对于结构化的数据，存在数据库、数据仓库、数据集市里，就用关联规则方法进行挖掘，原来如此！我悟了！终于把这两个东西串起来了</p>
</li>
<li><p>认识数据、数据预处理</p>
<ul>
<li><p>属性（即DW中的维度&#x2F;ML中的特征）</p>
<p>标称属性、二元属性、序数属性、数值属性(区间标度属性|比率标度属性)</p>
</li>
<li><p>基本统计描述</p>
<p>中心趋势（均值、中位数、众数）</p>
<p>数据分布（极差、方差、四分位数）</p>
<p>图形表示（盒图、分位数图）</p>
</li>
<li><p>相似性度量、相关性分析</p>
</li>
<li><p>数据预处理</p>
<p>准确性、完整性、一致性、时效性、可信性和可解释性</p>
<p>数据清洗</p>
<p>数据集成--》涉及冗余和相关分析--》</p>
<ul>
<li><p>卡方检验</p>
</li>
<li><p>相关系数和协方差</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>关联规则挖掘</p>
</li>
</ul>
<p>关联规则挖掘是一种在大规模数据集中发现项之间的关联关系的数据挖掘技术。它主要用于揭示数据中的频繁模式，并生成可以描述这些模式之间关联的规则。</p>
<p>在关联规则挖掘中，数据通常以事务的形式表示，其中每个事务由一组项组成。例如，在零售业中，一笔交易可以表示为一个事务，其中包含购买的商品项。关联规则的目标是发现<strong>频繁项集，即经常同时出现在事务中的项集</strong>。基于这些频繁项集，可以生成关联规则，描述项之间的关联关系。</p>
<p>关联规则通常使用两个度量来评估它们的质量：支持度（support）和置信度（confidence）。<strong>支持度表示项集在数据集中出现的频率</strong>，<strong>置信度表示规则的准确性</strong>。通过设置支持度和置信度的阈值，可以筛选出具有足够频繁和可靠关联关系的规则。</p>
<p>算法如Apriori或FP-Growth可以用于<strong>自动发现频繁项集和计算支持度和置信度</strong>。<strong>Apriori算法</strong>是一种基于候选生成和剪枝的经典算法，而<strong>FP-Growth算法</strong>则采用基于前缀树的高效数据结构来挖掘频繁模式。</p>
<ul>
<li><p>掌握基本概念</p>
<p>频繁项集：support &gt;&#x3D; min_sup</p>
<p>强关联规则：support &gt;&#x3D; min_sup &amp;&amp; confidence &gt;&#x3D; min_conf</p>
<p>两者关系：频繁项集是发现关联规则的基础，而强关联规则是基于频繁项集进一步筛选和评估的结果。频繁项集提供了挖掘关联规则的候选项，而强关联规则提供了更具有信心和准确性的关联关系。</p>
<p>支持度：支持度(A) &#x3D; (包含项集A的事务数量) &#x2F; (总事务数量)</p>
<p>置信度：置信度(A → B) &#x3D; (同时包含项集A和B的事务数量) &#x2F;<br>(只包含项集A的事务数量)</p>
</li>
<li><p>理解频繁模式挖掘算法原理</p>
<p>水平数据挖掘</p>
<ul>
<li><p>Apriori</p>
<ol>
<li><p>Apriori算法（候选生成与测试）：<br>Apriori算法是一种典型的基于候选生成和测试的频繁模式挖掘算法。该算法的基本思想是通过<strong>迭代地生成候选项集</strong>，并通过扫描事务数据来测试候选项集的支持度。</p>
</li>
<li><p>Apriori算法的步骤如下：</p>
</li>
</ol>
<ul>
<li><p>第一步，生成频繁1项集：扫描事务数据，计算每个项的支持度，筛选出支持度高于阈值的频繁1项集。</p>
</li>
<li><p>第二步及之后的步骤，生成候选项集和测试支持度：基于频繁k-1项集，通过连接操作生成候选k项集。然后，扫描事务数据，计算候选项集的支持度，并筛选出支持度高于阈值的频繁k项集。这个过程迭代进行，直到没有更多的频繁项集生成为止。</p>
</li>
</ul>
<ol>
<li>Apriori算法的优点是简单易懂，但对于大规模数据集而言，候选项集的生成和测试的过程可能非常耗时。</li>
</ol>
</li>
<li><p>FPgrowth</p>
<ol>
<li><p>通过构建数据结构来减少候选项集的生成和测试过程。FP-Growth算法的基本思想是构建一种称为FP树（Frequent<br>Pattern Tree）的数据结构，用于存储频繁模式的信息。</p>
</li>
<li><p>FP-Growth算法的步骤如下：</p>
</li>
</ol>
<ul>
<li><p>第一步，构建FP树：扫描事务数据，统计每个项的频数，并根据频数从高到低对项进行排序。然后，构建FP树，将事务数据插入树中，并使用项的频数作为节点值。</p>
</li>
<li><p>第二步，生成频繁模式：从FP树中获取频繁1项集，并通过条件模式基和递归方法生成频繁模式。<strong>条件模式基是指以某个项为结尾的路径集合。</strong></p>
</li>
<li><p>接着生成对应条件FP树，进而生成对应的频繁项集</p>
</li>
</ul>
<ol>
<li>基于投影的算法通过FP树的数据结构和条件模式基的利用，避免了显式地生成候选项集和计算支持度的过程，从而在一定程度上提高了算法的效率和性能。</li>
</ol>
</li>
<li><p>垂直数据挖掘</p>
<ul>
<li>基于迭代式求交集计算频繁项集</li>
</ul>
</li>
</ul>
</li>
<li><p>其他常用的关联规则兴趣度评价度量</p>
<p>提升度Lift&#x3D;P(AVB)&#x2F;P(A)P(B)</p>
<ul>
<li>提升度 &gt;1：表示X和Y之间存在正向关联，X的出现增加了Y的概率。</li>
</ul>
</li>
<li><p>提升度 &#x3D; 1：表示X和Y之间独立，X的出现对Y的概率没有影响。</p>
</li>
<li><p>提升度 &lt;1：表示X和Y之间存在负向关联，X的出现降低了Y的概率。</p>
<p>全置信度、最大置信度、Kulczynski（Kulc）、余弦</p>
<p>零事务：不包含任何考察项集的事务</p>
<p>零事务不变性（null-invariant）: 值不受零事务的影响，<br>以上4个都是</p>
<p>不平衡比（IR）</p>
</li>
<li><p>数据仓库应用</p>
<ul>
<li>DW基本概念</li>
</ul>
<p>DW是OLAP的范畴，是面向主题、集成的、时变的、非易失的有组织的数据集合</p>
<p>ETL是指数据仓库中的一个关键过程，它代表了数据的抽取（Extract）、转换（Transform）和加载（Load）的过程。</p>
<p>元数据是关于数据的数据，分类：业务元数据、技术元数据、管理元数据</p>
<p><strong>数据湖</strong>可以被视为一个存储数据的平台，它可以是数据仓库的一部分，也可以作为数据仓库的数据源之一。数据湖可以用于存储原始和未加工的数据，而数据仓库通常包含经过清洗、转换和整合的数据。</p>
<p><strong>数据治理</strong>是在数据湖和数据仓库中实施的数据管理和控制框架。数据治理确保数据的质量、准确性和合规性，无论数据是存储在数据湖还是数据仓库中。</p>
<p><strong>数据仓库</strong>通常是经过精心设计和建模的数据库，用于支持特定的业务分析和决策需求。数据湖可以作为数据仓库的数据源，提供原始和未加工的数据，以供数据仓库进行进一步的转换和整合。</p>
<ul>
<li>DW的设计建模</li>
</ul>
</li>
</ul>
<p>数据立方体、事实表（维度外键和指标）、维表（这个维下的细分维）</p>
<p>根据维表中，一个维度对应一个表的是<strong>星型模式</strong>，对应多个表的是<strong>雪花模式</strong>，多个事实表共享维表的是事实<strong>星座模型</strong></p>
<p>OLAP的多维分析操作包括：<strong>钻取、上卷、切片、切块以及旋转</strong></p>
<p><strong>湖仓一体架构</strong>（Lakehouse Architecture）是将数据湖（DataLake）和数据仓库（DataWarehouse）的概念结合起来的一种数据架构。</p>
<p>通过数据湖的灵活性和数据仓库的可靠性，湖仓一体架构提供了一个统一的数据管理和分析平台，支持从原始数据到洞察见解的全过程。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/" rel="tag">数据仓库</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/" rel="tag">数据挖掘</a></li></ul>

    </footer>
  </div>

    
 
   
  
</article>

    
    <article
  id="post-编译原理"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/02/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"
    >编译原理</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/02/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" class="article-date">
  <time datetime="2023-07-02T15:01:55.000Z" itemprop="datePublished">2023-07-02</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%90%8E%E5%A4%87%E7%AE%B1/">后备箱</a>
  </div>
 
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>分析阶段：词法分析、语法分析、语义分析。和源代码相关</p>
<p>综合阶段：中间代码生成、代码生成、代码优化。和目标代码相关</p>
<p>广义上编译指把高级语言等价转换成低级的汇编或机器语言</p>
<p>编译过程逻辑上包括6个阶段，这样最后出来的是汇编语言</p>
<p>词法分析检测非法字符，生成标记流</p>
<p>语法分析识别是什么语句，检测语法规则错误，生成语法树</p>
<p>语义分析</p>
<p>这门课学的怎么是把这六个阶段用程序实现</p>
<p>编译程序分成前端和后端，前端和机器无关，后端与源代码无关</p>
<h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>词法分析阶段，非块结构语言还不能存进符号表</p>
<p>🐾LEX</p>
<p>单缓冲区–</p>
<p>一符一种不需要属性，因为种类已经包含了信息</p>
<p>正则文法是让机器识别的，记号的模式用正则表达式描述</p>
<p>因为正则定义式和正则文法相似，因此可以用正则定义式把正则表达式转换成正则文法</p>
<p>斜体是非终结符</p>
<p>词法分析器主要在怎么让机器识别出是标识符还是常数，或是注释等等，这些由正则文法提供定义，识别出后根据记号的转换规则输出记号流和创建符号表即可</p>
<h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>上4周共16周，占比期末45%左右</p>
<h4 id="自顶向下"><a href="#自顶向下" class="headerlink" title="自顶向下"></a>自顶向下</h4><p><strong>递归下降分析</strong></p>
<p>少用，他是为了引出递归预测和非递归，后两者重要，这三种方法是用来构建分析树的方法，方法是利用文法去匹配，看这个句子是不是这个文法产生的，从而根据文法生成分析树</p>
<p>只含有终结符号的句型是句子</p>
<p><strong>递归调用预测分析</strong></p>
<p>要求文法不含左递归(通过消除左递归)，并且候选式的FIRST终结符互不相同(通过提取左公因子做到)，因此能做到指定唯一准确的候选式去匹配而不需要一个个试探</p>
<p>消除左递归：先消除间接左递归，再消除直接左递归</p>
<p>方法就是：先文法规范化，画出状态图，化简状态图(带 ‘ 的消掉)，构造程序</p>
<p><strong>非递归预测分析</strong></p>
<p>词法分析的结束符是EOF，语法分析的结束符是$</p>
<p>这种分析方法，重点就是分析表的构造</p>
<p>🎈FOLLOW、FIRST集合考试必考</p>
<p>FOLLOW集合其实就是某文法中，每个非终结符后会出现的所有终结符和$，只用在非终结符能推出空时，主要还是用FIRST</p>
<p>FIRST集合其实就是某文法中，符号能推出的前面终结符</p>
<p>FIRST集合不迭代，终结符开头就是终结符，非终结符开头copy那个非终结符发FIRST</p>
<p>FOLLOW集合要迭代，处理对象是非终结符，若E-&gt;TQ，Q-&gt;W|xita，那还要把T的FOLLOW给E，因为存在E-&gt;T的情况</p>
<p>求 Follow 集合的意思就是求非终结符右边所有终结符的集合</p>
<p>🎈判定LL(1)文法条件两点</p>
<h4 id="自底向上"><a href="#自底向上" class="headerlink" title="自底向上"></a>自底向上</h4><p>“移进规约”重点</p>
<p>LR(k)分析</p>
<p>栈里不会存在句柄，因为都规约掉了</p>
<p>活前缀就是当前符号栈里的符号串</p>
<p>LR(0)项目集规范族其实就是所有状态集</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/henuliulei/p/10872483.html">LL(1),LR(0),SLR(1),LALR(1),LR(1)对比与分析</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40147863/article/details/93253171">LR 分析法与构造 LR(1) 分析表的步骤 - 例题解析</a></p>
<p>对于 I0 ：<br>首先 S’ → .S, # 这个是固定的，就是第一个状态的核心项目<br>下面对 S 求向前所有符都没问题，都是 #<br>到了 L→.*R，这里，求向前搜索符，使用 FIRST(βa)<br>应该是求 FIRST(&#x3D;R#) 所以就是 &#x3D; 了</p>
<p>为什么是 &#x3D;R#?</p>
<p>因为 β 表示由谁哪个非终结符推导的，这里就是上面状态【S→.L&#x3D;R, #】这个非终结符 L 的后面的剩余串是 &#x3D;R，a 表示它上一个状态中的向前搜索符，就是 #，拼接起来就是 &#x3D;R#。</p>
<p>那么总结起来，求L-&gt;*R的FIRST(ba)向前搜索符，其实就是在求</p>
<p><strong>（0）S’→S</strong><br> <strong>（1）S→L&#x3D;R</strong> <strong>这个L之后的终结符，包括&#x3D;R以及S后会出现的字符<br> （2）S→R</strong><br> <strong>（3）L→*R</strong><br> <strong>（4）L→id</strong><br> <strong>（5）R→L</strong></p>
<p>注意哦，求的是谁的向前搜索符呢？是这个L非终结符的向前搜索符，</p>
<p>归约项目[A-&gt;a.，a1a2…ak ]意味着，当它所属项目集对应的状态在栈顶，且后续的k个输入符号为 a1a2…ak时，才允许把栈顶的文法符号串a归约为A。</p>
<p>具体构造方法：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Vm4y1Q7XB/?spm_id_from=333.337.search-card.all.click">www.bilibili.com</a></p>
<p>就是移进的照抄上一个状态对应的向前字符串，遇到非终结符新展开式子的向前字符串则是在当前状态下，看是在哪个语境下会碰到这个情况，则在这个语境下看向前字符串，结合视频后部分讲I1、I2部分理解</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Cu411m7VX/?spm_id_from=333.337.search-card.all.click&vd_source=bc9cf340bfb1db6ccb8942f02f068394">3如何求first集和follow集</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1GR4y137Qy/?spm_id_from=333.337.search-card.all.click&vd_source=bc9cf340bfb1db6ccb8942f02f068394">4构造LL(1)文法完整分析过程</a></p>
<p>项目数从少到多：LR(0)-&gt;SLR(1)-&gt;LALR(1)-&gt;LR(1)</p>
<p>SLR的项目数和状态机的状态数差不多，LR(1)的项目数多很多，而LALR(1)项目数没有比SLR(1)多多少并且判断的能力和LR(1)接近，LALR(1)是对LR(1)的优化，是通过合并同心集做到的</p>
<p>LL和LR区别</p>
<h3 id="期中复习"><a href="#期中复习" class="headerlink" title="期中复习"></a>期中复习</h3><p>顺一顺：</p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1081509964404543488">编译工程课程 - 知乎 (zhihu.com)</a></p>
<p><strong>词法分析</strong></p>
<p>记号(二元组)、模式(正则式、正则文法、DFA)</p>
<p>线性文法、DFA、正则式</p>
<p>要求会写出三者转换：</p>
<ul>
<li>正则文法-DFA</li>
</ul>
<p>根据左线性文法对应的状态转换图分析文法句子，是自底向上的，左线性文法所有推导都在左边</p>
<p>根据右线性文法对应转换图分析，是自顶向下的，右线性文法所有的推导都在右边</p>
<ul>
<li>正则文法-正则式</li>
</ul>
<p>正规文法与正规式都是描述正规集的工具。对任意一个正规文法，存在定义统一语言的正规式；反之，对每个正规式存在一个生成同一语言的正规文法。</p>
<p><strong>改造文法成右线性文法</strong></p>
<p>就先根据文法写出产生的语言，再根据语言构造等价的右线性文法</p>
<p><strong>改造文法成LL1文法</strong></p>
<ol>
<li><p>消除左递归</p>
</li>
<li><p>消除回溯（不含左公因子，参考下面文法判断第2条）</p>
</li>
</ol>
<p><strong>语法分析</strong></p>
<p><strong>自顶向下：LL(1)</strong></p>
<ul>
<li>LL(1)文法判断</li>
</ul>
<p>一个文法如果满足以下三条：<br> 1）文法不含左递归 像这个样子A-&gt;Ab是不允许的<br> 2）对于文法中每一个非终结符A的各个产生式的候选首符集两两不相交。<br> 即对于A-&gt;α1|α2|…|αn，要求FIRST（αi）∩FIRST（αj）&#x3D;Ø （i≠j）<br> 3）对于文法中的每个非终结符A，若它存在某个候选首符集包含ε，则<br> FIRST（A）∩FOLLOW（A）&#x3D;Ø</p>
<p>对产生式中A-&gt;C|B这样带有分号的式子，判断C和B的首字母是不是相同，相同就不是LL(1)，即对每个进行FIRST交集判断是否为空，若C|B有能推出$的，看FOLLOW(A)和另一个的FIRST交集是否空</p>
<img src="/2023/07/02/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/clip_image004.png" class="" title="标题: fig:">

<p><strong>证明是LR(1)需要构造出DFA，而LL(1)的构造直接根据上面规则就可以</strong></p>
<ul>
<li>FIRST&#x2F;FOLLOW集构造</li>
</ul>
<p>注意求FOLLOW集的时候，遇到空记得带入🫡，也就是说FOLLOW是不能写空的，只能写非终结符和结束符$</p>
<img src="/2023/07/02/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/clip_image006.png" class="" title="标题: fig:">



<ul>
<li>LL(1)分析表长这样</li>
</ul>
<p>先消除左递归，写出FIRST|FOLLOW，画分析表(横批是终结符+$)</p>
<img src="/2023/07/02/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/clip_image008.png" class="" title="标题: fig:">



<p><strong>自底向上：SLR(1)、LR(1)、 LALR(1)</strong></p>
<p>自底向上的文法是允许有左递归和，但需要先写拓广文法（加S’，展开，编号）</p>
<p>这三者的判断：是不是SLR1就先写出LR0，若有冲突，看FOLLOW交集是不是空。不是空就无法解决，继续看LR1能否解决。而LALR1是在LR1基础上，把同心集合并，如果没有同心集，就直接是LALR1，如果有，不存在归约-归约冲突，那就是LALR1</p>
<p> 构造项目集规范族、识别文法的DFA、分析表</p>
<p> 各文法特点、区分</p>
<ul>
<li>LR(1)分析表长这样</li>
</ul>
<p>向前搜索符其实就是，当前式子左边在当前I状态下，向前看一位会出现的终结符或#</p>
<h5 id=""><a href="#" class="headerlink" title=""></a><img src="/2023/07/02/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/clip_image010.png" class="" title="标题: fig:"></h5><p>LR(1)比SLR(1)改进在哪呢？不都是查看FOLLOW集来解决冲突吗？就我的感受是，SLR(1)只是查看总的产生式下的FOLLOW集，是粗略的比对，而LR(1)更加细致，查看的是每一个状态下的FOLLOW</p>
<p>分析表中的R是指R到哪个拓广文法中的产生式，S指S到哪个状态</p>
<p>怎么判断是否有移进-归约冲突？看.后的和,后的是否有相同</p>
<ul>
<li>短语、简单短语、判断句柄(期中考了)</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Ch411M7k5/?spm_id_from=333.788.recommend_more_video.2&vd_source=bc9cf340bfb1db6ccb8942f02f068394">编译原理之规范推导，语法树，短语，句柄，二义性，语言相关问题</a></p>
<ul>
<li>为什么要写拓广文法？</li>
</ul>
<p>拓广文法G的接受项目是唯一的(即S-&gt;S•)</p>
<p>因此，目的是创建一个只有唯一接受项目的与原文法等价的新文法。</p>
<p>意思就是为了把S放在右部</p>
<p>拓广文法要把右部有多种情况的分开写，特别是要求编号时</p>
<ul>
<li>LL(1)的含义</li>
</ul>
<p>第一个L表示从左至右扫描符号串</p>
<p>第二个L表示生成输入串的最左推导 (LR则是最右推导)</p>
<p>1表示在决定分析程序的每步动作时，向前看一个符号</p>
<p>构造SLR(1)分析表其实就是LR(0)分析表，只是说如果造出来的不存在冲突，那么就是SLR(1)</p>
<ul>
<li>同心集、核、向前搜索符</li>
</ul>
<p>B-&gt;A,$&#x2F;a</p>
<p>整个是同心集，左边产生式是核、右边是向前搜索符</p>
<p>LALR合并同心集后，会产生归约-归约冲突，如下，也就是合并后有多个归约项且向前搜索符相同</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/d359d3142346">编译器笔记16-语法分析-LALR分析法 - 简书 (jianshu.com)</a></p>
<img src="/2023/07/02/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/clip_image012.png" class="" title="标题: fig:">



<ul>
<li>递归下降分析方法（期中考了）</li>
</ul>
<h4 id="编译概述"><a href="#编译概述" class="headerlink" title="编译概述"></a>编译概述</h4><p>编译6步骤：词法分析、语法分析、语义分析、中间代码生成、代码优化、目标代码生成</p>
<h4 id="语法制导翻译"><a href="#语法制导翻译" class="headerlink" title="语法制导翻译"></a>语法制导翻译</h4><p>就是在语法分析过程中嵌入语义动作</p>
<ul>
<li>判断语法制导定义</li>
</ul>
<p>是S属性&#x2F;L属性定义</p>
<ul>
<li>翻译方案</li>
</ul>
<p>区别于语法制导定义，在于前者多了语义动作和花括号Hhh</p>
<p>要根据语法制导定义设计翻译方案</p>
<p>翻译方案其实就是把语义规则加到产生式中，加了个花括号</p>
<ul>
<li>树</li>
</ul>
<p>目前这门课学了分析树、注释分析树、语法树、dag图都要会构造</p>
<ul>
<li>运行环境</li>
</ul>
<p>调用序列，活动记录：参数域、控制链、访问链</p>
<p>带(*)没讲，display表不讲</p>
<ul>
<li>中间代码生成</li>
</ul>
<p>开始分析阶段，之前一直到语义分析，都是综合阶段，本阶段输入时语义分析输出的带有语义的语法树</p>
<ul>
<li>目标代码生成</li>
</ul>
<p>只讲了：基本块、程序流图（CFG）</p>
<ul>
<li>代码优化</li>
</ul>
<p>只讲了：中间代码优化（基本块优化、循环优化）</p>
<p>1、2章不考</p>
<p>题型：6道大题，没有小题</p>
<p>词法、语法分析和期中考的一样，也是3道题，但比期中难</p>
<p>语义分析第6章不考</p>
<p>语法制导翻译会考</p>
<p>中间代码生成要会写三地址语句，回填技术</p>
<h3 id="期末复习"><a href="#期末复习" class="headerlink" title="期末复习"></a>期末复习</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>编译程序分为分析阶段（词法、语法、语义分析，该阶段任务是把源程序转换成程序的内部表示）、综合阶段（中间代码生成、代码优化、目标代码生成，该阶段任务是把内部表示转换成目标程序）</p>
<h4 id="词法、语法分析-3"><a href="#词法、语法分析-3" class="headerlink" title="词法、语法分析-3"></a>词法、语法分析-3</h4><h4 id="语法制导翻译-1"><a href="#语法制导翻译-1" class="headerlink" title="语法制导翻译-1"></a>语法制导翻译-1</h4><ul>
<li>分析树（哪个表达式的分析树）</li>
<li>注释分析树（自底向上给每个节点符号加上属性值）</li>
<li>依赖图</li>
<li>语法制导定义：产生式+语义规则</li>
<li>写翻译方案</li>
<li>判断S属性、L属性</li>
</ul>
<p><strong>语法制导定义之属性设计思路总结：</strong></p>
<ul>
<li>二进制转十进制：综合属性S.vaL</li>
<li>输出括号嵌套深度：继承属性S.deep</li>
<li>输出括号配对个数：综合属性S.num</li>
</ul>
<p>总结下就是先画出语法分析树，观察，如果是在S’输出S的属性，则是定义综合属性，若是再符号中间输出，则是继承属性</p>
<h4 id="运行环境-1"><a href="#运行环境-1" class="headerlink" title="运行环境-1"></a>运行环境-1</h4><ul>
<li>参数传递机制： 过程套路如下</li>
</ul>
<p>​      <img src="/2023/07/02/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/clip_image022.png" class="" title="标题: fig:"></p>
<ul>
<li>访问链</li>
</ul>
<h4 id="中间代码生成、目标代码生成、代码优化-1"><a href="#中间代码生成、目标代码生成、代码优化-1" class="headerlink" title="中间代码生成、目标代码生成、代码优化-1"></a>中间代码生成、目标代码生成、代码优化-1</h4><p>都是套路：</p>
<ol>
<li><p>先对循环块B4内优化：删除公共子表达式、复制传播、删除死代码（合成一步）</p>
</li>
<li><p>再把B1和B4放一起优化：代码外提(地址)、削弱计算强度(*-&gt;+)、删除归纳变量(i删)</p>
</li>
<li><p>B3优化：if条件改成和i等价的变量条件</p>
</li>
<li><p>B1中的i删掉</p>
</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" rel="tag">编译原理</a></li></ul>

    </footer>
  </div>

    
 
   
  
</article>

    
    <article
  id="post-Nosql数据库技术"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/02/Nosql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF/"
    >Nosql数据库技术</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/02/Nosql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF/" class="article-date">
  <time datetime="2023-07-02T03:01:55.000Z" itemprop="datePublished">2023-07-02</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%90%8E%E5%A4%87%E7%AE%B1/">后备箱</a>
  </div>
 
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li><p><strong>NoSQL基本概念、CAP定理</strong></p>
<ul>
<li><p>C:Consistency（强一致性）<br>A:Availability（可用性）<br>P:Partition tolerance（分区容错性）</p>
</li>
<li><p>P指在出现网络分区（比如断网）的情况下，分离的系统也能正常运行</p>
</li>
<li><p>CAP理论的核心是：一个分布式系统不可能同时很好的满足这三个需求，</p>
</li>
</ul>
</li>
<li><p>NoSQL种类与特点</p>
</li>
<li><p>1）不需要预定义模式<br>2）无共享架构：因为从本地磁盘读取数据的性能往往好于通过网络传输读取数据的性能，从而提高系统的性能。</p>
<p>3）弹性可扩展：可以在系统运行的时候，动态增加或者删除结点。不需要停机维护，数据可以自动迁移。<br>4）分区：相对于将数据存放于同一个节点，NoSQL数据库需要将数据进行分区，将记录分散在多个节点上面。</p>
<p>5)分发查询到数据，而非数据到查询；</p>
<p>6）异步复制：NoSQL中的复制，往往是基于日志的异步复制。<br>7）BASE：相对于事务严格的ACID特性，NoSQL数据库更注重保障的是BASE特性。</p>
</li>
<li><p>四类：图、文档、键值、列族</p>
</li>
<li><p>ACID与BASE的区别</p>
<ul>
<li><p>关系型数据库中强调ACID分别是：原子性、一致性、隔离性、持久性</p>
</li>
<li><p>BASE分别是： 基本可用性、软状态、最终一致性</p>
</li>
<li><p>BASE就是为了解决关系数据库强一致性引起的问题而引起的可用性降低而提出的解决方案，它的思想是通过让系统放松对某一时刻数据一致性的要求来换取系统整体伸缩性和性能上改观。</p>
</li>
<li><p>但是并不是说NOSQL数据库就不支持ACID了</p>
</li>
</ul>
</li>
<li><p>最终一致性经典算法</p>
<ul>
<li><p>Raft算法</p>
<ul>
<li>Leader、Follower、Candidate</li>
</ul>
</li>
<li><p>Quorum的NWR策略</p>
<ul>
<li><p>Vr + Vw &gt; V：保证一定能读到最新的数据</p>
</li>
<li><p>Vw &gt; V&#x2F;2：只需要写一半的节点就能向用户报告完成写入操作</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>数据复制与分片机制的作用</p>
</li>
</ul>
<h3 id="图数据库"><a href="#图数据库" class="headerlink" title="图数据库"></a>图数据库</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><ul>
<li><p>图数据库的特点</p>
<ul>
<li><p>图数据库是以实体及其关系为主要存储对象的数据<br>库系统，存储图结构的数据具有突出优势。</p>
</li>
<li><p>非原生图存储类：指底层采用键值数据库、文档数据库、列族数据库或者其他类型通<br>用数据库存储图数据。通常需要建立全局索引来提高图数据的访问性能</p>
</li>
<li><p>原生图存储类：一般采用免索引邻接的方式进行图数据存储，数据存储机制可快速<br>寻址定位到相关连的节点、关系，此种存储方式性能大大提高，可<br>以很好地支持原生图处理引擎进行图数据计算</p>
</li>
</ul>
</li>
<li><p>关键数据要素</p>
<ul>
<li><p>标签：指节点、关系的类别</p>
</li>
<li><p>一个节点可以具有<strong>零个</strong>或多个类别标签；而一个关系<strong>必须有且只有一个</strong>关系类型。</p>
</li>
<li><p>RDB一行数据对应GDB中的一个节点，表名称对应节点的一个标签名称，即代表节点的一种类别。</p>
</li>
<li><p>也就是说GDB相当于把多个RDB合在一块</p>
</li>
</ul>
</li>
<li><p>属性图</p>
</li>
<li><p>属性图是图数据库建模常用的方法，也就是让画的那个作业</p>
<p>节点和关系都有标签、属性组成，属性由k-v表示</p>
<img src="/2023/07/02/Nosql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF/rId33.png" class="">
</li>
<li><p>图查询语言</p>
<ul>
<li><p>Neo4j-&gt;Cypher语言</p>
</li>
<li><p>Cypher是一个声明式模式匹配语言，语法在于定义要从图中查询什么目标数据，从查询条件、返回结果两方面定义节点、关系及其属性，而不是怎么去查</p>
</li>
<li><p>属性名称、标签与关系类型名称区分大小写</p>
</li>
<li><p>开始节点、关系、结束节点的详细内容限定组合在一起称<br>为一个匹配模式，匹配模式也可以定义为一个变量，便于<br>查询匹配模式重用</p>
</li>
<li><p>Cypher语法</p>
<ul>
<li><p>节点：(a:person{name:”王五” ，age:26})</p>
</li>
<li><p>关系：(a)-[r:friend_of{year:2019,type: &quot;football&quot;}]-&gt;(<br>b )</p>
</li>
<li><p>（a）--&gt;（）--&gt;（b）</p>
</li>
<li><p>（a）-[*3]-&gt;（b）</p>
</li>
<li><p>（a）-[*3..5]-&gt;（b）</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Neo4j"><a href="#Neo4j" class="headerlink" title="Neo4j"></a>Neo4j</h4><ul>
<li><p>基于JAVA的<strong>原生图</strong>数据库</p>
</li>
<li><p>Cypher语法</p>
<ul>
<li><p>DELETE-删除节点、关系</p>
</li>
<li><p>REMOVE删除属性、标签</p>
</li>
</ul>
</li>
<li><p>因果集群架构</p>
</li>
<li><p>因果集群按节点在集群中的操作任务分工，主要分为两类</p>
<ul>
<li><p>核心服务器：处理读写的操作，大多数的核心服务器主要处理写操作。</p>
</li>
<li><p>读复制服务器：集群中可以包含一个或多个只负责分担读数据任务的服务器，数据从核心服务器异步更新，保持一致。</p>
</li>
<li><p>架构中核心服务器基于<strong>Raft</strong>协议维护和管理</p>
</li>
<li><p>M&#x3D;2F+1来计算集群中核心服务器的数量规模</p>
<ul>
<li><p>F ：为容错服务器数量</p>
</li>
<li><p>M ：为核心服务器总数量</p>
</li>
</ul>
</li>
<li><p><strong>如果可容忍1台故障服务器，则需要配置3台服务器。</strong></p>
</li>
<li><p>Neo4j高可用性（HA）集群采用主从式架构，可以1主多从。主服务器完成写入之后，同步数据到从服务器，<strong>主服务器既可以写也能读</strong>。Neo4j从节点可以处理写入，<strong>不需要都从主节点直接写入</strong>。但为保持数据一致性，从节点将写请求发给主节点同步处理写入<br>。然而更新操作最终从主节点传播到从节点，所以一个从节点的写入在其他所有从节点上<strong>不是立即可见</strong>的。</p>
</li>
</ul>
</li>
</ul>
<h3 id="文档数据库"><a href="#文档数据库" class="headerlink" title="文档数据库"></a>文档数据库</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><ul>
<li><p>文档数据库是最像RDB的NOSQL数据库</p>
</li>
<li><p>MongoDB中的数据存储用的是BSON，就是二进制JSON，相比于JSON，在数据访问性能上有很大的提升，且数据类型更丰富</p>
</li>
<li><p>文档、集合、数据库--&gt;行、表、数据库</p>
</li>
<li><p>MongoDB有以下4个保留的默认创建的数据库</p>
<ul>
<li><p>admin：这个是根级数据库，从权限的角度来看，是系统管理员级操作的数据库。</p>
</li>
<li><p>local：这个数据库不会被复制，它所存储的任何collections只能在各自的服务器实例上，可以用来存储限于本地单台服务器访问的任意集合。</p>
</li>
<li><p>config：在分布式分片设置时，将用于存储配置相关的信息。</p>
</li>
<li><p>test：<strong>默认连接的数据库</strong></p>
</li>
</ul>
</li>
<li><p>ObjectId包含标识<strong>产生时间</strong>、机器标识、<strong>进程</strong>和<strong>自增序列</strong>四方面内容</p>
</li>
<li><p>文档模型设计基本原则：相关字段，经常一起访问的字段设 计在一个文档中</p>
</li>
<li><p>文档关联有三种方法：嵌套文档、_id引用、DBRef引用(可跨数据库)</p>
</li>
<li><p>时序文档数据 模型设计：分桶优化模式</p>
</li>
<li><p>应用</p>
<ul>
<li><p>内容管理系统及博客平台：用来管理用户评论、用户注册、用户配置和面向Web文档。</p>
</li>
<li><p>视频直播场景：可以使用文档数据库存储用户信息、礼物信息以及视频数据元信息等。</p>
</li>
<li><p>日志数据存储与分析，用来存储”页面浏览量”（pageview）或”独立访客数”（uniquevisitor）等，可以无需改变模式即可新增度量标准。</p>
</li>
<li><p>电子商务应用场景：以存储产品目录、订单信息等</p>
</li>
</ul>
</li>
</ul>
<h4 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h4><ul>
<li><p>MongoDB<strong>没有创建数据库的命令</strong>，但可以先<code>use mytest</code><br>再添加一个集合<code>db.createCollection(&#39;user&#39;)</code>，这样可以建立。</p>
</li>
<li><p>MongoDB集合创建时<strong>不一定</strong>必须先创建集合再插入数据，若用创建语句，支持集合的文档限定总数设置：<code>db.createCollection(&quot;iLog&quot;,&#123; capped : true, size : 6142800, max :  10000 &#125;)</code></p>
</li>
<li><p>命名规范：</p>
<p>区分大小写</p>
<p>UTF-8 字符，不能包含 &#39;\0&#39; 字符(空字符)</p>
<p>&#39;.&#39; 和&#39;$&#39; 有特殊含义，需要避免使用</p>
</li>
<li><p>操作</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">增：db.ct.insert([&#123;aaa&#125;,&#123;sss&#125;])</span><br><span class="line">查</span><br><span class="line">  db.ct.find() 、db.getCollection(&#x27;ct&#x27;).find(&#123;&#125;)</span><br><span class="line">  查询满足条件的首个文档：db.ct.findOne()</span><br><span class="line">  1表示升序，-1表示降序：db.ct.find().sort(&#123;age:1&#125;)</span><br><span class="line">  函数使用语法大致是：$xx:，如：</span><br><span class="line">  -db.ct.find(&#123;age:&#123;$in:[23,26,32]&#125;&#125;)</span><br><span class="line"></span><br><span class="line">  -db.ct.find(&#123;$or:[&#123;age:&#123;$lte:23&#125;&#125;,</span><br><span class="line">      &#123;age:&#123;$gte:33&#125;&#125;]&#125;)</span><br><span class="line">删</span><br><span class="line">  db.ct.deleteOne(&#123;&quot;age&quot;:&#123;$gt:25&#125;&#125;) 、db.ct.deleteMany(&#123;&quot;age&quot;:&#123;$gt:25&#125;&#125;)</span><br><span class="line">  删除所有：db.ct.drop()、db.ct.remove(&#123;&#125;)</span><br><span class="line">更</span><br><span class="line">  没有匹配文档时，执行插入操作：db.ct.updateMany(&#123;&quot;Name&quot; :&quot;Chen&quot;&#125;,&#123;$set &#123;&quot;custLvl&quot;:2,&quot;score&quot; :90&#125;&#125;,&#123;upsert:true&#125;)</span><br><span class="line"></span><br><span class="line">聚合、管道</span><br><span class="line">  unwind：将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值；</span><br></pre></td></tr></table></figure>

<ul>
<li><p>索引机制</p>
<p>MongoDB会为每个集合的_id字段默认创建索引，MongoDB支持全文索引、地理位置索引</p>
<p>一个集合最多只能创建一个文本索引</p>
<pre><code>有时在不确定哪些字段是文本类型时，也可以使用&quot; $**&quot;通配说明符对 所有文本类型字段创建全文索引，如下示例
db.collection.createIndex( &#123; &quot;$**&quot;: &quot;text&quot; &#125; )
创建
1、-1升/降序：db.ct.createIndex(&#123;&quot;Name&quot;:1,&quot;gender&quot;:-1&#125;)
查询
db.ct.getIndexes()
① 查询包含&quot;bad&quot;的文档。
db.collection.find( &#123;$text :&#123;$search: &quot;bad&quot;&#125; &#125;)
② 查询包含&quot;bad&quot; 或者 &quot;spoiled&quot;的文档，查询参数中用空格间隔开多
个关键词即可。
db.collection.find( &#123; $text :&#123;$search: &quot;bad spoiled &quot;&#125; &#125;)
③ 查询包含&quot;bad&quot; 不包含 &quot;ok&quot;的文档，在不需要包含的关键词前加符号&quot;-&quot;。
db.collection.find( &#123;$text:&#123;$search: &quot;bad -ok &quot;&#125; &#125;)
④ 查询包含&quot;not ok&quot;完整词组的文档，在完整词组前后用引号括起来。
db.collection.find( &#123; $text :&#123;$search: &quot;&quot;not ok&quot;&quot;&#125; &#125;
删除
db.ct.dropIndexes()
db.ct.dropIndex(&quot;Name_1&quot;)
</code></pre>
<p>地理位置索引支持是MongoDB的一大亮点</p>
<p>地理位置索引一般分为以下两种</p>
<p>2d索引：用于存储和查找平面上的点，称为平面地理位置索引；</p>
<p>2dsphere索引：用于存储和查找球面上的点，称为球面地理位置索引。</p>
<p>2dsphere索引<strong>只支持</strong>球面几何地理位置查询，而2d索引同时支持平面和球面几何地理位置查询。</p>
</li>
<li><p>集群架构</p>
<p>分片集组成：shard(存储实际数据块)、router mongos(前端路由)、configserver</p>
<p>分片集和复制集还是不一样的，一个是解决数据太多的存储问题，一个是解决节点瘫痪的备份问题</p>
<p>分片是以集合为基本单位的。集合中的数据通 过片键（ShardKey）被分成多个部分，选择的片键要求每个文档都必须包含。相同片键值的文档一定会处于同一个块（Chunk）中</p>
<p>片键的选择主要有两个原则：片键基数大、片键分布均匀</p>
<p>复制集集群(主从)是一组在不同服务器节点<strong>存储相同分片</strong>数据的mongodb进程</p>
<p>写入操作都在<strong>主节点</strong>上，主节点记录在其上的所有操作，存储为<strong>opLog</strong>日志文件</p>
<p>复制集集群中可以有一个<strong>Arbiter</strong>类型节点：<strong>只参与投票</strong>，不能被选为<br>Primary，也不与Primary同步数据</p>
<p>Arbiter本身<strong>不存储数据</strong>，是非常轻量级的服务。</p>
<p>GridFS 用于存储和恢复超过16MB的文件，如 图片、音频、视频</p>
<p>将大文件对象分割成多个小的数据块（chunks），一般每个数据块默认为255KB，作为MongoDB的一个文档存储在Chunks集合中</p>
<p><strong>Journaling</strong></p>
<p>日志功能使数据库在意外故障后快速恢复<strong>最近checkpoint</strong>后的数据更新操作，本质上是一种变更操作持久化预写（Write ahead）机制，WiredTiger存储引擎会先将 Journal日志写入<strong>内存缓冲区</strong>，满足一定条件时再写入磁盘Journal <strong>日志文件</strong></p>
</li>
</ul>
<h3 id="键值数据库"><a href="#键值数据库" class="headerlink" title="键值数据库"></a>键值数据库</h3><h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><p>一般这种数据库是放在内存的，高速访问</p>
<h5 id="存储逻辑架构"><a href="#存储逻辑架构" class="headerlink" title="存储逻辑架构"></a>存储逻辑架构</h5><img src="/2023/07/02/Nosql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF/rId42.png" class="">

<ul>
<li>String</li>
</ul>
<p>String 类型不是用&#x2F;0来判断字符串结束，是二进制安全的，即 String可以是任何数据，如JPG格式图片、音频、视频等其他类型序列化的对象，并不局限于通常意义上的字符序列数据</p>
<p>Redis使用sdshdr结构来表示字符串对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct sdshdrX &#123;</span><br><span class="line">T len; //存储实际字符串长度</span><br><span class="line">T alloc; //预分配存储数据总长度</span><br><span class="line">unsigned char flags; //具体类型</span><br><span class="line">char buf[]; //数据存储区</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Redis也是采用<strong>String来存储数值</strong>类型值的，前提是字符串是能够转换成合法的数值数据</p>
<ul>
<li>List</li>
</ul>
<p>双向字符串列表，按照插入顺序排序，是有序的，且成员允许重复，列表最多可存储 2^32 - 1 个元素</p>
<p>lpush(从左插入值) lrange(获取列表值)</p>
<ul>
<li>Set</li>
</ul>
<p>String类型的无序集合</p>
<p>集合是通过哈希表实现的，所以添加、删除、查找的复杂度，都是O(1)<br>集合最多可存储 2^32 – 1个元素<br>集合内元素具有唯一性，第二次插入的内容被忽略</p>
<p>sadd(返回1: 成功；0：已存在) smembers(查看元素)</p>
<ul>
<li>Hash</li>
</ul>
<p>hmset hget hvals</p>
<ul>
<li>Zset</li>
</ul>
<p>要求member不能重复</p>
<img src="/2023/07/02/Nosql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF/rId45.png" class="">

<p>与set不同在于，这个是有序集合，每个元素比set多一个score，用来成员排序</p>
<p>zadd(zadd tzset 0 red) 0是score，red是value</p>
<ul>
<li>Stream</li>
</ul>
<p>消息队列是持久化的， Redis重启后内容还在</p>
<p>是一个消息链表，将所 有加入的消息都串起来 ，每个消息都有一个唯一的ID和对应的内容</p>
<img src="/2023/07/02/Nosql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF/rId48.png" class="">

<p>一个元素只能被组中一个消费者进行消费</p>
<p>每个消费组都含有一个Last_delivered_id，指向消费组当前已消费的最后一个消息。</p>
<h6 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h6><ul>
<li>持久化管理</li>
</ul>
<p>RDB持久化：内存快照，写入磁盘，只有<strong>一份</strong>RDB文件，可随时备份，比AOF文件<strong>小</strong>，加载效率高，提供FORK子进程，<strong>不阻塞主进程</strong>，IO操作比较少</p>
<p>AOF持久化：日志记录每个写操作，APPEND方式追加日志，不会对旧日志文件产生影响</p>
<ul>
<li>分区</li>
</ul>
<p>范围分区、哈希分区</p>
<ul>
<li>集群监控：哨兵</li>
</ul>
<p>哨兵任务：问候主从节点、其他哨兵</p>
<p>主观下线：有节点在心跳检测时超时没回，就认为sdown</p>
<p>客观下线：<strong>主节点</strong>超时没回，且问了其他哨兵节点，一定数量认为下线，就认为odown</p>
<p>当主节点被判断<strong>客观下线以后</strong>，各个哨兵节点会进行协商，选举出一个领导者哨兵节点，并由该<strong>哨兵领导者节点</strong>对其进行<strong>故障迁移</strong>操作(选举使用Raft，先到先得，即在一轮选举中哨兵A向B发送成为领导者的申请，如果B没有同意过其他哨兵，则会同意A成为领导者&#x2F;quorums机制：哨兵数&#x2F;2+1)</p>
<p>哨兵至少需要3个实例，来保证自己的健壮性</p>
<h4 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h4><p>Redis：REmote DIctionary Server 远程字典服务</p>
<ul>
<li>语法</li>
</ul>
<p>发布订阅：订阅者收到的每条消息是个<strong>三元组</strong>，&quot;message&quot;&quot;发布者&quot;&quot;具体内容&quot;</p>
<p>事务管理：所有单个操作都是<strong>原子</strong>性的，多个原子操作可通过MULTI和EXEC指令包起来作为一个整体执行，但Redis 没有在事务上增加任何维持原子性的机制，所以Redis事务可以理解为一个打包的批量执行脚本。中间某条指令的失败<strong>不会</strong>导致前面已成功执行指令的<strong>回滚</strong>，后续的指令<strong>继续</strong>执行。</p>
<p>有效期：设置有效期-&gt;expire key 600(单位s)，查看剩余时间-&gt;ttl key</p>
<p>List操作中，lindex是从0开始的</p>
<p>LREM key count element：LREM mylist -2<br>&quot;hello&quot;表示从右往左删除2个hello，count&gt;0从左往右，&lt;0右到左，&#x3D;0删除所有</p>
<p>LRANGE mylist 0 -1：表示左到右查看所有元素</p>
<ul>
<li>集群架构</li>
</ul>
<p>主节点分片集群时<strong>无中心架构</strong>的，每个主节点保存部分键值对数据和整个集群状态,每个节点都和其他<br>所有节点连接。</p>
<p>集群采用哨兵机制保障 HA，节点的失效是在集群中<br><strong>超过半数</strong>的节点检测失效时 才生效。</p>
<p>客户端写入操作与Redis节点直接链接，无需代理，连接集群<br>中<strong>任何一个可用节点</strong>即可</p>
<p><strong>键的自动分片机制</strong>：键-&gt;slot-&gt;节点</p>
<p>Redis支持将不同的键映射到相同的槽（slot）</p>
<p><strong>副本漂移机制</strong>：有主节点没有从节点，并且其他主节点有&gt;&#x3D;2的从节点给他，那就有最多的主节点分一个给他</p>
<h3 id="列族数据库"><a href="#列族数据库" class="headerlink" title="列族数据库"></a>列族数据库</h3><h4 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h4><h5 id="集群架构"><a href="#集群架构" class="headerlink" title="集群架构"></a>集群架构</h5><p>主从式(HBase)：会出现单点故障问题</p>
<p>对等式(Cassandra)：不会出现单点故障问题，彼此问候</p>
<p>提交日志（CommitLog）：是Cassandra中的崩溃恢复 机制</p>
<p>一个列族CF对应一个memtable，memtable满足一定条件后批量刷新到磁盘，同时在memtable里会按key排下序</p>
<p>SStable一旦完成写入，就不可变更，只能读取。memtable写入时不会进行排序插入，而是SStable定期自己合并排序</p>
<img src="/2023/07/02/Nosql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF/rId56.png" class="">

<h5 id="存储逻辑架构-1"><a href="#存储逻辑架构-1" class="headerlink" title="存储逻辑架构"></a>存储逻辑架构</h5><p>列、行、列族、键空间-&gt;列、行、表、数据库</p>
<p>一个集群可以包含多个键空间</p>
<p>可以大致看出列族数据库展示上和RDB相似，但实际在磁盘上存储是按照一列一列存储的</p>
<img src="/2023/07/02/Nosql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF/rId60.jpg" class="">

<p>数据存储是按行键排序的</p>
<p>主键(分区键、聚类键)：分区、聚类键都可以有多列，聚类键决定在分区内的排序，默认升序</p>
<p>静态列：Cassandra 中是<strong>不支持 join</strong>的，静态列用于存储需要同一分区中共享的数据列，所有<br>值均为最后一次更改后的值。静态列不能是主键的组成部分</p>
<pre><code>#表中定义列为 STATIC ，只需在列最后面加上 STATIC ：
CREATE TABLE &quot;iteblog_users_with_status_updates&quot; (
&quot;username&quot; text,
&quot;id&quot; timeuuid,
&quot;email&quot; text STATIC,
&quot;encrypted_password&quot; blob STATIC,
&quot;body&quot; text,
PRIMARY KEY (&quot;username&quot;, &quot;id&quot;));
</code></pre>
<p>如果没有定义 clustering column，意味着相同 PRIMARY KEY的数据在同一个分区里面只存在一行数据，本质上就是静态的，所以也没必要支持静态列，如同上面的例子。</p>
<h5 id="对等式架构"><a href="#对等式架构" class="headerlink" title="对等式架构"></a>对等式架构</h5><p>写流程：收到操作请求的节点作为代理节点，向n个副本节点发送请求，追加CommitLog更新MemTable的节点返回成功，满足一致性级别要求返回成功</p>
<p>读流程：同样做代理，返回k个节点返回数据中最新的数据</p>
<p>一致性要求高时，推荐R+W&gt;N；<br>实时性要求高时，推荐R+W&lt;N；<br>在实际应用中，经常设置为2、2、3；</p>
<p>分区策略🫡</p>
<h4 id="cassandra"><a href="#cassandra" class="headerlink" title="cassandra"></a>cassandra</h4><p>是对等式的</p>
<p>自定义元组不需要再定义元素名称</p>
<p>CQL标识符和关键字是大小写不敏感</p>
<p>要插入数据，必须存在相应表。表可用的列也是预先定义的。</p>
<p>要删除表，也必须确保表存在</p>
<p>UPDATE一般不会检查行是否存在，若不存在则创建，否则更新</p>
<p>更新列时，需要列是已定义存在的列，否则将报错</p>
<p>删除并非立即删除，它执行的是插入操作，插入的数据叫作tombstone（墓碑)，记录了被删除记录的信息和删除时间，在TTL到期和进行SStable压紧操作时，丢弃墓碑，创建新索引</p>
<p>一级索引：通过主键快速访问数据</p>
<p>二级索引：通过其他列快速访问数据</p>
<p>创建二级索引的名称可省略</p>
<h3 id="区块链存储技术"><a href="#区块链存储技术" class="headerlink" title="区块链存储技术"></a>区块链存储技术</h3><p>区块链数据存储技术是一种分布式、去中心化的数据存储方式，它基于区块链技术的原理和特性。在传统的中心化数据存储系统中，数据通常由中央机构或第三方管理，而区块链数据存储技术则将数据存储和管理权力分散到网络中的多个节点。</p>
<p>区块链数据存储技术的主要特点包括：</p>
<ol>
<li><p>分布式存储：数据在区块链网络中的多个节点上进行存储，而不是集中存储在单个服务器或数据中心中。这种分布式的特性增加了系统的可靠性和抗攻击性。</p>
</li>
<li><p>去中心化：区块链数据存储技术没有中心化的管理机构，数据由网络中的多个节点协作维护和验证。这意味着没有单个点的故障会导致数据的丢失或不可用。</p>
</li>
<li><p>不可篡改性：区块链中的每个数据块都包含了前一个数据块的哈希值，形成了一个不可篡改的链式结构。一旦数据被添加到区块链中，很难修改或删除，确保数据的完整性和可信性。</p>
</li>
<li><p>高透明度：区块链网络中的每个节点都可以查看和验证存储在区块链上的数据，使得数据的透明度非常高。这对于需要公开和可追溯的数据存储场景非常有用。</p>
</li>
<li><p>加密安全：区块链数据存储技术通常使用密码学算法对数据进行加密，确保数据的安全性和隐私性。只有授权的用户才能访问和修改数据。</p>
</li>
</ol>
<ul>
<li><p>作为一个分布式存储系统来说，同样需要在CAP三方面进行抉择由于当前的网络硬件肯定会出现延迟丢包等问题，所以分区容忍性（P）是必须要实现的。大数据是以牺牲一致性（C）来换取可用性（A）。区块链则允许数据存储有一定延迟，牺牲一定的可用性（A），优先保证一致性（C）</p>
</li>
<li><p>区块是一种记录交易的数据结构。每个区块由区块头和区块主体组成，区块主体只负责记录前一段时间内的所有交易信息，区块链的大部分功能都由区块头实现。</p>
</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Nosql/" rel="tag">Nosql</a></li></ul>

    </footer>
  </div>

    
 
   
  
</article>

    
    <article
  id="post-基于大数据的机器学习理论"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/09/07/%E5%9F%BA%E4%BA%8E%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BA/"
    >机器学习理论</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/09/07/%E5%9F%BA%E4%BA%8E%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BA/" class="article-date">
  <time datetime="2022-09-06T23:58:06.000Z" itemprop="datePublished">2022-09-07</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%90%8E%E5%A4%87%E7%AE%B1/">后备箱</a>
  </div>
 
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>机器学习什么意思？</p>
<p>目前都有什么方法学习？</p>
<h4 id="逻辑模型"><a href="#逻辑模型" class="headerlink" title="逻辑模型"></a>逻辑模型</h4><p>假设空间计算：每个属性包含特定值和“？”，最后再加上一种每个样例都是反例这一特殊极端情况。(看逻辑模型中的样例)</p>
<p>概念学习：从特殊例集中归纳出一般概念，又称归纳学习。通俗讲，从一堆样例，通过它是这个东西， 它有哪些属性，从特殊序假设不断学习到适用于所有样例的一般化，得到一个模型来泛化预判是否是   它。</p>
<p>该思路算法有：</p>
<p>FIND-S</p>
<p>运用了极大特殊假设，不断泛化正例样本模型，忽略反例样本。不能保证涵盖所有正例，因此不能判断 反例，且只得到假设空间的一个假设，并且是极大特殊假设。对于噪声无能为力，数据只能是离散的</p>
<p>🎈候补消除法</p>
<p>学习的仍然是正例的表达，得到的是版本空间，而不是某一版本，解决了FIND-S的一大弊端。</p>
<p>做法是，基于正例泛化同时，也基于反例特殊化(但仍是正例属性值表达)，从而获得一个上下界。</p>
<p>🎈决策树(ID3) 期末会考多维的</p>
<p>CART树：分类，回归</p>
<p>计算：基于信息熵选取最大价值属性、基于基尼指数选取最大价值属性</p>
<h4 id="几何模型"><a href="#几何模型" class="headerlink" title="几何模型"></a>几何模型</h4><p>利用几何特征构建的学习模型线性回归</p>
<p>优化各点到直线距离，使期望方差最小</p>
<p>🎈线性分类器(Fisher) <strong>–还需看怎么用拉格朗日乘子求解准则函数，进而得w, b</strong></p>
<p>优化投影轴，最大化准则函数，类间距最大，类内距最小</p>
<p>SVM</p>
<p>优化最近两点间隔，找到支持向量，不要求推导</p>
<p>KNN</p>
<p>有监督分类，对于一个点不重复计算，但每个点都要计算离其他点的距离，找出离他最近的k个点投票。</p>
<p>🎈K-means聚类</p>
<p>无监督聚类，随机选出k个中心，每个点计算到k个中心的距离，归到最近下面。在对新类计算均值选出 新中心，重复上述操作，直到中心不变。</p>
<h4 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h4><p>BPNN, Back Propagation Neural Network，是最基础的神经网络，其输出结果采用前向传播，误差采用反向（Back Propagation）传播方式进行。BP神经网络是有监督学习。</p>
<p>🎈多层</p>
<p>随机梯度下降的思想是 根据每个单独样例的误差增量地计算权值更新，得到近似的梯度下降搜索。神经网络两步骤：前向传播、反向传播(采用梯度下降对每层权值修正)</p>
<h4 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h4><p>正则化的<strong>目的是限制参数过多或者过大，避免模型更加复杂</strong>。经验误差、泛化误差</p>
<p><strong>过拟合</strong></p>
<p>训练误差小，测试误差和泛化误差大，无法彻底避免解决：降低模型复杂度，增大训练数据</p>
<p><strong>欠拟合</strong></p>
<p>泛化误差和测试误差、训练误差都大解决：增强模型复杂度，增大训练数据</p>
<p>怎么从样本中分出测试集去很好地评估模型？</p>
<p>数据量足够：留出法、m折交叉验证法（很大数据量不用，因为计算量大，且数据量巨大时也用不着这么充分地用数据了）</p>
<p>数据量小：自助法模型性能度量</p>
<p>回归：均方误差</p>
<p>分类：错误率、精度</p>
<p>单个二分类：查全率、查准率</p>
<p>多个二分类：宏查全率宏查准率、微查全率微查准率</p>
<p>回归模型的泛化误差分解：样本自身噪声、期望误差、数据偏差扰动</p>
<h3 id="计算学习理论"><a href="#计算学习理论" class="headerlink" title="计算学习理论"></a>计算学习理论</h3><p> 想知道：学习出来的结果可不可靠？可信度是多少？怎么样做能使结果可靠？</p>
<p>现在所学的基础是训练数据和泛化数据独立同分布，否则错误率会很高，不在目前能力范围内，属于前 沿研究</p>
<p>假设空间：针对某个任务，所有的可能模型</p>
<p>🎈有限假设空间可分&#x2F;不可分情形下的样本数目，要求会推导 关注样本复杂度为多少时，是PAC可学习的：</p>
<p>PAC学习强调的是泛化误差要能够以一定的概率被控制在 一定的范围之内</p>
<p>理解：可知PAC可学习，学到的是概念，表示你选择的模型类可以达到没有泛化误差，即你的模型类是正确的，因此要做的是极限减小泛化误差。</p>
<p>不可知PAC可学习，学不到概念，做的是在现选空间下，使训练误差逼近最小泛化误差，让你训练出的结果模型不断极限到你选择的模型类能达到的最小泛化误差，从而减小泛化误差，但相比于可知情形， 能减小到的泛化误差存在最小值。</p>
<p>如果你选择的空间(如线性分类对某任务训练出的所有线)的最小泛化误差就是比较大，那么最终再怎么训 练，误差都会大，因此选择合适的空间很关键。</p>
<p>可不可知，即概念是否能知道能学到</p>
<p>大多数假设空间都是无限的，也就概念模型中的假设空间是有限的对无限的假设空间进行某种分类：从假设空间的分类能力的来分类不要求无线假设空间的推导，但需要了解：</p>
<p>VC维-&gt;衡量无限假设空间大小的度量</p>
<p>增长函数H’-&gt;空间里有多少种不同表达能力的假设，使无限变有限，替代有限空间中空间大小H 任何VC维有限的的假设空间H都是（不可知） PAC可学习的。</p>
<h3 id="概率模型"><a href="#概率模型" class="headerlink" title="概率模型"></a>概率模型</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Mr_health/article/details/107596402">(16条消息) 【机器学习】判别模型vs生成模型、概率模型vs非概率模型<em>Mr_health</em>的博客*-CSDN*博客对于</a></p>
<p> <a target="_blank" rel="noopener" href="https://blog.csdn.net/Mr_health/article/details/107596402">包含 k 个类别的分类问题,分析比较一下线性判别函数模型、概率生成 模型和概</a></p>
<ul>
<li>判别概率模型</li>
</ul>
<p>逻辑斯蒂模型(介绍她是为了了解最大似然、最小交叉熵的概念，且在某些分类问题上，有用)</p>
<p>把分类模型映射成概率的模型，选的是逻辑斯蒂函数，因此建的模型叫逻辑斯蒂模型，函数得出的就是 后验概率，因此是判别式概率模型</p>
<ul>
<li>生成概率模型</li>
</ul>
<p>贝叶斯决策：就是最大后验概率决策</p>
<p>朴素贝叶斯模型，根据贝叶斯决策进行决策的模型，直白说就是求出P(Y|X)，看谁最大算哪个拉普拉斯修正是个小tip，实际使用朴素要用</p>
<h4 id="交叉熵"><a href="#交叉熵" class="headerlink" title="交叉熵"></a>交叉熵</h4><p>交叉熵损失函数可以用来衡量两个分布到差异，通常用来衡量预测与真实值间的差异</p>
<p>损失函数和似然函数就差一个负号，但通常希望使用最小化，因此加个负号的损失函数使用更多，但两 种的评估策略不同</p>
<p>有些人嫌多项逻辑斯蒂回归麻烦，因此搞成了softmax回归，</p>
<p>如：做k分类，多项逻辑斯蒂回归只建k-1个类，而softmax建k类。两者没有本质区别，只是形式不同， 也因此softmax回归模型有参数冗余</p>
<p><strong>作业：基于交叉熵最小化，对softmax参数梯度优化：</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44538273/article/details/86671655"> 损失函数]Softmax求导_急流勇进的博客-CSDN博客</a></p>
<p>因为softmax公式的特性，它的分母包含了所有神经元的输出，所以，对于不等于i的其他输出里面，也包含在内 ，因此需要分为k&#x3D;m和k≠m，</p>
<h4 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h4><p>对于图像、语音等很难做特征工程等预处理，因此有了深度学习，融合了表征学习和预测网络，实现了 端到端的方式</p>
<h3 id="概率模型总结"><a href="#概率模型总结" class="headerlink" title="概率模型总结"></a>概率模型总结</h3><p>概率模型就是通过求P(Y|X)来给出Y类别</p>
<p>有两种方法：</p>
<p>判别式，直接求各自的P(Y|X)，再用最大似然求解</p>
<p>生成式，先求出联合概率P(X,Y)，再用贝叶斯公式获得P(Y|X)&#x3D;P(X,Y)&#x2F;P(X)</p>
<p><strong>后验概率</strong>：事情已经发生，属性已经存在，根据这个果这个属性去计算因|类别的概率是多少  <strong>最大似然估计</strong>：取最可能导致该结果的参数</p>
<p><strong>似然函数</strong>：P(Y|X)</p>
<p>回归很简单，一行套公式的代码就能建模</p>
<h3 id="卷积神经网络-1"><a href="#卷积神经网络-1" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h3><p>思路：一些人认为，人眼能够很好识别，是因为人们观察的是重要关键的局部而非全部细节，视野是多 层，组合起来最终形成视觉信息。</p>
<p><strong>卷积操作</strong>和普通操作的区别在于卷积操作的是矩阵，但都是对所有x进行线性运算再累加，最后过激活函 数</p>
<p><strong>2维卷积</strong>根据从哪开始做分成full same valid(对边缘信息的关注程度不同)，在做运算时，会先对h(m,n)</p>
<p>做旋转180，但真正在操作时，会觉得旋转很麻烦，免去旋转直接算，h(m,n)是卷积核&#x2F;特征滤波器</p>
<p><strong>卷积输出的矩阵高</strong>&#x3D;((x的高-h的高)&#x2F;步长)+1，<strong>宽</strong>也是一样算  卷积层常用激活函数<strong>RELU</strong></p>
<p>sigmoid函数易产生梯度消失的情况，当梯度消失时，无法通过梯度优化参数，性能不佳。RELU不会有梯度消失的问题</p>
<p>参数初始化尽可能小,学习率也不能过大，防止relu dead</p>
<p><strong>多层卷积</strong>就是把多层各自和卷积核卷完后累加成一层<strong>多通道卷积</strong>就是并行多通道地用不同核做卷积</p>
<p><strong>池化</strong>有最大池化、平均池化，就是对池化滤波器套中的小池中取最大值或取平均值，是为了压缩图像， 突出特征。</p>
<p>多深叫深度学习网络📢</p>
<p>没有标准答案，多数人将多层神经网络，且隐藏层中用了特殊处理如卷积，称为深度学习 深度会比宽度好</p>
<h3 id="大作业"><a href="#大作业" class="headerlink" title="大作业"></a>大作业</h3><p><strong>训练集</strong></p>
<p>训练集用来训练模型，即确定模型的权重和偏置这些参数，通常我们称这些参数为学习参数。</p>
<p><strong>验证集</strong></p>
<p>而验证集用于模型的选择，更具体地来说，验证集并不参与学习参数的确定，也就是验证集并没有参与 梯度下降的过程。验证集只是为了选择超参数，比如网络层数、网络节点数、迭代次数、学习率这些都 叫超参数。比如在k-NN算法中，k值就是一个超参数。所以可以使用验证集来求出误差率最小的k。</p>
<p><strong>测试集</strong></p>
<p>测试集只使用一次，即在训练完成后评价最终的模型时使用。它既不参与学习参数过程，也不参数超参 数选择过程，而仅仅使用于模型的评价。</p>
<p>值得注意的是，千万不能在训练过程中使用测试集，而后再用相同的测试集去测试模型。这样做其实是 一个cheat，使得模型测试时准确率很高。</p>
<h3 id="循环神经网络-RNN-LSTM-集成学习"><a href="#循环神经网络-RNN-LSTM-集成学习" class="headerlink" title="循环神经网络 RNN LSTM 集成学习"></a>循环神经网络 RNN LSTM 集成学习</h3><p>端到端，是相对于 非端到端 而言的。在机器学习最开始的时候，人们并不是直接输入原始数据，获得最终结果；而是首先通过特征提取，对原始数据进行初步的处理，然后再对于得到的特征进行学习，得出  分类or回归的结果。比如使用一些hand-crafted functions作为特征描述符等等。</p>
<p>因此，在这种情况下（非端到端），特征的提取会对模型的最终表现有着巨大的影响。而特征描述符的 书写又具有很大的经验成分，所以是一件比较困难的任务。</p>
<p>端到端的学习，就是把特征提取的任务也交给模型去做，直接输入原始数据或者经过些微预处理的数   据，让模型自己进行特征提取。 这一种设计风格在神经网络，尤其是深层的神经网络出现后开始被广泛应用，无疑是得益于算力的提升。并且，神经网络可以很好地学习到特征的描述，之前需要人工设计的 特征算子，本身也可以通过神经网络的方式，让模型自己习得，从而可以用于其他的任务以及更深的研 究。</p>
<p>在图像领域，CNN就是一个很典型的端到端结构。输入图像，输出可以做分类，可以做补全，做各种任 务。这之中的具体细节都不需要人工干预，这就是End-to-end。</p>
<p>就是说深度学习构建的模型还比机器学习多了一个特征提取的模型，因此在深度学习会有很多层致力于 表征学习</p>
<h3 id="集成学习-强化学习"><a href="#集成学习-强化学习" class="headerlink" title="集成学习 强化学习"></a>集成学习 强化学习</h3><h4 id="bagging-并行"><a href="#bagging-并行" class="headerlink" title="bagging 并行"></a>bagging 并行</h4><p>数据集分成多个不同子集，每个独立训练弱学习器，分类问题用投票(若是加权，就是stacking)，回归用均值</p>
<ul>
<li>随机森林</li>
<li>自主随机</li>
</ul>
<h4 id="boosting-串行"><a href="#boosting-串行" class="headerlink" title="boosting 串行"></a>boosting 串行</h4><p>在之前的弱学习器上修改权值得到下一个弱学习器，最终的强学习器是所有的弱学习器在权重上的和 不同样本权重产生不同的样本数据集，他不分，他用不同权重区分</p>
<ul>
<li>adaboost</li>
</ul>
<h4 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h4><p>区别于监督学习，没有样本，学习过程不断产生样本，问题中有状态、动作和单步回报，基于产生的数据使回报最大化</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="tag">机器学习</a></li></ul>

    </footer>
  </div>

    
 
   
  
</article>

    
  </article>
  

  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2023
        一只鼻孔
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/3.jpg" alt="一只鼻孔在路上"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://music.163.com/outchain/player?type=4&id=985447545&auto=0&height=200">音乐</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://feelma.lofter.com/">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>